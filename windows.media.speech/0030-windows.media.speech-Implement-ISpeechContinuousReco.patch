From a32e2343f80583c193c0c5c09e3caebc27ee4a3d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Bernhard=20K=C3=B6lbl?= <besentv@gmail.com>
Date: Fri, 4 Feb 2022 15:36:22 +0100
Subject: [PATCH v2 30/45] windows.media.speech: Implement
 ISpeechContinuousRecognitionSession add/remove_ResultGenerated.

---
 .../speechcontinuousrecognition.c             | 55 ++++++++++++++++++-
 1 file changed, 52 insertions(+), 3 deletions(-)

diff --git a/dlls/windows.media.speech/speechcontinuousrecognition.c b/dlls/windows.media.speech/speechcontinuousrecognition.c
index 327cfd940e7..5074267a074 100644
--- a/dlls/windows.media.speech/speechcontinuousrecognition.c
+++ b/dlls/windows.media.speech/speechcontinuousrecognition.c
@@ -309,12 +309,20 @@ struct completed_event
     struct list entry;
 };
 
+struct result_event
+{
+    ITypedEventHandler_SpeechContinuousRecognitionSession_SpeechContinuousRecognitionResultGeneratedEventArgs *handler;
+    EventRegistrationToken token;
+    struct list entry;
+};
+
 struct speech_continuous_recognition_session
 {
     ISpeechContinuousRecognitionSession ISpeechContinuousRecognitionSession_iface;
     LONG ref;
 
     struct list completed_event_list;
+    struct list result_event_list;
 };
 
 /*
@@ -510,15 +518,55 @@ static HRESULT STDMETHODCALLTYPE speech_continuous_recognition_session_add_Resul
     ITypedEventHandler_SpeechContinuousRecognitionSession_SpeechContinuousRecognitionResultGeneratedEventArgs *handler,
     EventRegistrationToken *token)
 {
-    FIXME("iface %p, handler %p, token %p, stub!\n", iface, handler, token);
-    return E_NOTIMPL;
+    struct speech_continuous_recognition_session *impl = impl_from_ISpeechContinuousRecognitionSession(iface);
+    struct result_event *event, *new_event;
+
+    TRACE("iface %p, handler %p, token %p, stub!\n", iface, handler, token);
+
+    if (!(new_event = calloc(1, sizeof(*new_event))))
+    {
+        return E_OUTOFMEMORY;
+    }
+
+    new_event->handler = handler;
+    new_event->token.value = 0;
+
+    LIST_FOR_EACH_ENTRY(event, &impl->result_event_list, struct result_event, entry)
+    {
+        if(event->token.value > new_event->token.value)
+        {
+            new_event->token.value = event->token.value + 1;
+        }
+    }
+
+    list_add_head(&impl->result_event_list, &new_event->entry);
+
+    *token = new_event->token;
+
+    TRACE("ret handler %p, token.value %#I64x\n",  new_event->handler, new_event->token.value);
+
+    return S_OK;
 }
 
 static HRESULT STDMETHODCALLTYPE speech_continuous_recognition_session_remove_ResultGenerated(
     ISpeechContinuousRecognitionSession *iface, EventRegistrationToken token)
 {
+    struct speech_continuous_recognition_session *impl = impl_from_ISpeechContinuousRecognitionSession(iface);
+    struct result_event *event;
+
     FIXME("iface %p, token %p, stub!\n", iface, token);
-    return E_NOTIMPL;
+
+    LIST_FOR_EACH_ENTRY(event, &impl->result_event_list, struct result_event, entry)
+    {
+        if(event->token.value == token.value)
+        {
+            list_remove(&event->entry);
+            free(event);
+            return S_OK;
+        }
+    }
+
+    return E_FAIL;
 }
 
 static const struct ISpeechContinuousRecognitionSessionVtbl 
@@ -563,6 +611,7 @@ HRESULT STDMETHODCALLTYPE speech_continuous_recognition_session_create(ISpeechCo
     impl->ref = 1;
 
     list_init(&impl->completed_event_list);
+    list_init(&impl->result_event_list);
 
     *out = &impl->ISpeechContinuousRecognitionSession_iface;
     return S_OK;
-- 
2.34.1

