From e5736956e7c91b52206f81b58ea6297c9ba06713 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Bernhard=20K=C3=B6lbl?= <besentv@gmail.com>
Date: Sun, 30 Jan 2022 15:11:45 +0100
Subject: [PATCH v2 23/45] windows.media.speech: Add
 SpeechRecognitionListConstraint stub.

---
 dlls/windows.media.speech/Makefile.in         |   1 +
 dlls/windows.media.speech/main.c              |   7 +
 .../speechrecognitionlistconstraint.c         | 574 ++++++++++++++++++
 dlls/windows.media.speech/tests/speech.c      | 344 +++++++++++
 .../windows_media_speech_private.h            |   1 +
 5 files changed, 927 insertions(+)
 create mode 100644 dlls/windows.media.speech/speechrecognitionlistconstraint.c

diff --git a/dlls/windows.media.speech/Makefile.in b/dlls/windows.media.speech/Makefile.in
index 8a9b5b2cf7d..b9c78f705a8 100644
--- a/dlls/windows.media.speech/Makefile.in
+++ b/dlls/windows.media.speech/Makefile.in
@@ -4,6 +4,7 @@ IMPORTS = combase uuid
 
 C_SRCS = \
 	main.c \
+	speechrecognitionlistconstraint.c \
 	speechrecognizer.c \
 	speechsynthesizer.c
 
diff --git a/dlls/windows.media.speech/main.c b/dlls/windows.media.speech/main.c
index 072c6ba314b..2eea8f3ff7f 100644
--- a/dlls/windows.media.speech/main.c
+++ b/dlls/windows.media.speech/main.c
@@ -47,6 +47,13 @@ HRESULT WINAPI DllGetActivationFactory(HSTRING classid, IActivationFactory **fac
         IUnknown_AddRef(*factory);
         return S_OK;
     }
+    else if (IsEqualClassID(WindowsGetStringRawBuffer(classid, NULL),
+        L"Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint"))
+    {
+        speech_recognition_list_constraint_get_activation_factory(factory);
+        IUnknown_AddRef(*factory);
+        return S_OK;
+    }
 
     ERR("Unknown classid %s.\n", debugstr_hstring(classid));
     return CLASS_E_CLASSNOTAVAILABLE;
diff --git a/dlls/windows.media.speech/speechrecognitionlistconstraint.c b/dlls/windows.media.speech/speechrecognitionlistconstraint.c
new file mode 100644
index 00000000000..5eb0f9feb1b
--- /dev/null
+++ b/dlls/windows.media.speech/speechrecognitionlistconstraint.c
@@ -0,0 +1,574 @@
+/* WinRT Windows.Media.SpeechRecognition implementation
+ *
+ * Copyright 2022 Bernhard KÃ¶lbl
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "windows_media_speech_private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(speech);
+
+/*
+ *
+ * SpeechRecognitionListConstraint
+ *
+ */
+
+struct speech_recognition_list_constraint
+{
+    ISpeechRecognitionListConstraint ISpeechRecognitionListConstraint_iface;
+    ISpeechRecognitionConstraint ISpeechRecognitionConstraint_iface;
+    LONG ref;
+};
+
+/*
+ *
+ * ISpeechRecognitionListConstraint
+ *
+ */
+
+static inline struct speech_recognition_list_constraint
+    *impl_from_ISpeechRecognitionListConstraint(ISpeechRecognitionListConstraint *iface)
+{
+    return CONTAINING_RECORD(iface, struct speech_recognition_list_constraint, ISpeechRecognitionListConstraint_iface);
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_list_constraint_QueryInterface(
+    ISpeechRecognitionListConstraint *iface, REFIID iid, void **out)
+{
+    struct speech_recognition_list_constraint *impl = impl_from_ISpeechRecognitionListConstraint(iface);
+
+    TRACE("iface %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IUnknown) ||
+        IsEqualGUID(iid, &IID_IInspectable) ||
+        IsEqualGUID(iid, &IID_ISpeechRecognitionListConstraint))
+    {
+        
+        IUnknown_AddRef(iface);
+        *out = iface;
+        return S_OK;
+    }
+
+    if(IsEqualGUID(iid, &IID_ISpeechRecognitionConstraint))
+    {
+        IUnknown_AddRef(iface);
+        *out = &impl->ISpeechRecognitionConstraint_iface;
+        return S_OK;
+    }
+
+    WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG STDMETHODCALLTYPE speech_recognition_list_constraint_AddRef(ISpeechRecognitionListConstraint *iface)
+{
+    struct speech_recognition_list_constraint *impl = impl_from_ISpeechRecognitionListConstraint(iface);
+
+    ULONG ref = InterlockedIncrement(&impl->ref);
+    TRACE("iface %p, ref %u.\n", iface, ref);
+
+    return ref;
+}
+
+static ULONG STDMETHODCALLTYPE speech_recognition_list_constraint_Release(ISpeechRecognitionListConstraint *iface)
+{
+    struct speech_recognition_list_constraint *impl = impl_from_ISpeechRecognitionListConstraint(iface);
+
+    ULONG ref = InterlockedDecrement(&impl->ref);
+    TRACE("iface %p, ref %u.\n", iface, ref);
+
+    if(!ref)
+        free(impl);
+
+    return ref;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_list_constraint_GetIids(
+    ISpeechRecognitionListConstraint *iface, ULONG *iid_count, IID **iids)
+{
+    FIXME("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_list_constraint_GetRuntimeClassName(
+    ISpeechRecognitionListConstraint *iface, HSTRING *class_name)
+{
+    FIXME("iface %p, class_name %p stub!\n", iface, class_name);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_list_constraint_GetTrustLevel(
+    ISpeechRecognitionListConstraint *iface, TrustLevel *trust_level)
+{
+    FIXME("iface %p, trust_level %p stub!\n", iface, trust_level);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_list_constraint_get_Commands(
+    ISpeechRecognitionListConstraint *iface, IVector_HSTRING **value)
+{
+    FIXME("iface %p, value %p stub!\n", iface, value);
+    return E_NOTIMPL;
+}
+
+static const struct ISpeechRecognitionListConstraintVtbl i_speech_recognition_list_constraint_vtbl =
+{
+    /* IUnknown methods */
+    speech_recognition_list_constraint_QueryInterface,
+    speech_recognition_list_constraint_AddRef,
+    speech_recognition_list_constraint_Release,
+    /* IInspectable methods */
+    speech_recognition_list_constraint_GetIids,
+    speech_recognition_list_constraint_GetRuntimeClassName,
+    speech_recognition_list_constraint_GetTrustLevel,
+    /* ISpeechRecognitionListConstraint methods */
+    speech_recognition_list_constraint_get_Commands
+};
+
+/*
+ *
+ * ISpeechRecognitionConstraint
+ *
+ */
+
+static inline struct speech_recognition_list_constraint 
+    *impl_from_ISpeechRecognitionConstraint(ISpeechRecognitionConstraint *iface)
+{
+    return CONTAINING_RECORD(iface, struct speech_recognition_list_constraint, ISpeechRecognitionConstraint_iface);
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_constraint_QueryInterface(ISpeechRecognitionConstraint *iface, REFIID iid, void **out)
+{
+    struct speech_recognition_list_constraint *impl = impl_from_ISpeechRecognitionConstraint(iface);
+
+    TRACE("iface %p, iid %s, out %p.\n", iface, debugstr_guid(iid), out);
+
+    /* IUnknown_QueryInterface already defined by ISpeechRecognitionListConstraint_iface. Redirect there. */
+    return ISpeechRecognitionListConstraint_QueryInterface(&impl->ISpeechRecognitionListConstraint_iface, iid, out);
+}
+
+static ULONG STDMETHODCALLTYPE speech_recognition_constraint_AddRef(ISpeechRecognitionConstraint *iface)
+{
+    struct speech_recognition_list_constraint *impl = impl_from_ISpeechRecognitionConstraint(iface);
+
+    TRACE("iface %p.\n", iface);
+
+    /* IUnknown_AddRef already defined by ISpeechRecognitionListConstraint_iface. Redirect there. */
+    return ISpeechRecognitionListConstraint_AddRef(&impl->ISpeechRecognitionListConstraint_iface);
+}
+
+static ULONG STDMETHODCALLTYPE speech_recognition_constraint_Release(ISpeechRecognitionConstraint *iface)
+{
+    struct speech_recognition_list_constraint *impl = impl_from_ISpeechRecognitionConstraint(iface);
+
+    TRACE("iface %p.\n", iface);
+
+    /* IUnknown_Release already defined by ISpeechRecognitionListConstraint_iface. Redirect there. */
+    return ISpeechRecognitionListConstraint_Release(&impl->ISpeechRecognitionListConstraint_iface);
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_constraint_GetIids(
+    ISpeechRecognitionConstraint *iface, ULONG *iid_count, IID **iids)
+{
+    struct speech_recognition_list_constraint *impl = impl_from_ISpeechRecognitionConstraint(iface);
+
+    TRACE("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
+
+    /* IInspectable_GetIids already defined by ISpeechRecognitionListConstraint_iface. Redirect there. */
+    return ISpeechRecognitionListConstraint_GetIids(&impl->ISpeechRecognitionListConstraint_iface, iid_count, iids);
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_constraint_GetRuntimeClassName(
+    ISpeechRecognitionConstraint *iface, HSTRING *class_name)
+{
+    struct speech_recognition_list_constraint *impl = impl_from_ISpeechRecognitionConstraint(iface);
+
+    TRACE("iface %p, class_name %p stub!\n", iface, class_name);
+
+    /* IInspectable_GetRuntimeClassName already defined by ISpeechRecognitionListConstraint_iface. Redirect there. */
+    return ISpeechRecognitionListConstraint_GetRuntimeClassName(&impl->ISpeechRecognitionListConstraint_iface, class_name);
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_constraint_GetTrustLevel(
+    ISpeechRecognitionConstraint *iface, TrustLevel *trust_level)
+{
+    struct speech_recognition_list_constraint *impl = impl_from_ISpeechRecognitionConstraint(iface);
+
+    TRACE("iface %p, trust_level %p stub!\n", iface, trust_level);
+
+    /* IInspectable_GetTrustLevel already defined by ISpeechRecognitionListConstraint_iface. Redirect there. */
+    return ISpeechRecognitionListConstraint_GetTrustLevel(&impl->ISpeechRecognitionListConstraint_iface, trust_level);
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_constraint_get_IsEnabled(
+    ISpeechRecognitionConstraint *iface, BOOLEAN *value)
+{
+    FIXME("iface %p, value %p stub!\n", iface, value);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_constraint_put_IsEnabled(
+    ISpeechRecognitionConstraint *iface, BOOLEAN value)
+{
+    FIXME("iface %p, value %u stub!\n", iface, value);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_constraint_get_Tag(
+    ISpeechRecognitionConstraint *iface, HSTRING *value)
+{
+    FIXME("iface %p, value %p stub!\n", iface, value);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_constraint_put_Tag(
+    ISpeechRecognitionConstraint *iface, HSTRING value)
+{
+    FIXME("iface %p, value %p stub!\n", iface, value);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_constraint_get_Type(
+    ISpeechRecognitionConstraint *iface, SpeechRecognitionConstraintType *value)
+{
+    FIXME("iface %p, value %p stub!\n", iface, value);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_constraint_get_Probability(
+    ISpeechRecognitionConstraint *iface, SpeechRecognitionConstraintProbability *value)
+{
+    FIXME("iface %p, value %p stub!\n", iface, value);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_constraint_put_Probability(
+    ISpeechRecognitionConstraint *iface, SpeechRecognitionConstraintProbability value)
+{
+    FIXME("iface %p, value %u stub!\n", iface, value);
+
+    return E_NOTIMPL;
+}
+
+static const struct ISpeechRecognitionConstraintVtbl i_speech_recognition_constraint_vtbl =
+{
+    /* IUnknown methods */
+    speech_recognition_constraint_QueryInterface,
+    speech_recognition_constraint_AddRef,
+    speech_recognition_constraint_Release,
+    /* IInspectable methods */
+    speech_recognition_constraint_GetIids,
+    speech_recognition_constraint_GetRuntimeClassName,
+    speech_recognition_constraint_GetTrustLevel,
+    /* ISpeechRecognitionConstraint methods */
+    speech_recognition_constraint_get_IsEnabled,
+    speech_recognition_constraint_put_IsEnabled,
+    speech_recognition_constraint_get_Tag,
+    speech_recognition_constraint_put_Tag,
+    speech_recognition_constraint_get_Type,
+    speech_recognition_constraint_get_Probability,
+    speech_recognition_constraint_put_Probability,
+};
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_list_constraint_create_with_tag(
+    IIterable_HSTRING *commands, HSTRING tag, ISpeechRecognitionListConstraint **listconstraint)
+{
+    struct speech_recognition_list_constraint *impl;
+    HRESULT hr;
+
+    FIXME("commands %p, tag %p, listconstraint %p. Stub!\n", commands, tag, listconstraint);
+
+    if(!commands)
+        return E_POINTER;
+
+    if (!(impl = calloc(1, sizeof(*impl))))
+    {
+        *listconstraint = NULL;
+        return E_OUTOFMEMORY;
+    }
+
+    impl->ISpeechRecognitionListConstraint_iface.lpVtbl = &i_speech_recognition_list_constraint_vtbl;
+    impl->ISpeechRecognitionConstraint_iface.lpVtbl = &i_speech_recognition_constraint_vtbl;
+    impl->ref = 1;
+    
+    hr = ISpeechRecognitionListConstraint_QueryInterface(&impl->ISpeechRecognitionListConstraint_iface, &IID_ISpeechRecognitionListConstraint, (void**)listconstraint);
+    ISpeechRecognitionListConstraint_Release(&impl->ISpeechRecognitionListConstraint_iface);
+
+    return hr;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_list_constraint_create(
+    IIterable_HSTRING *commands, ISpeechRecognitionListConstraint **listconstraint)
+{
+    TRACE("commands %p, listconstraint %p.\n", commands, listconstraint);
+    return speech_recognition_list_constraint_create_with_tag(commands, NULL, listconstraint);
+}
+
+/*
+ *
+ * ActivationFactory for Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint
+ *
+ */
+
+struct activation_factory
+{
+    IActivationFactory IActivationFactory_iface;
+    ISpeechRecognitionListConstraintFactory ISpeechRecognitionListConstraintFactory_iface;
+    LONG ref;
+};
+
+/*
+ *
+ * IActivationFactory
+ *
+ */
+
+static inline struct activation_factory *impl_from_IActivationFactory(IActivationFactory *iface)
+{
+    return CONTAINING_RECORD(iface, struct activation_factory, IActivationFactory_iface);
+}
+
+static HRESULT STDMETHODCALLTYPE activation_factory_QueryInterface(
+    IActivationFactory *iface, REFIID iid, void **out)
+{
+    struct activation_factory *impl = impl_from_IActivationFactory(iface);
+
+    TRACE("iface %p, iid %s, out %p stub!\n", iface, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IUnknown) ||
+        IsEqualGUID(iid, &IID_IInspectable) ||
+        IsEqualGUID(iid, &IID_IAgileObject) ||
+        IsEqualGUID(iid, &IID_IActivationFactory))
+    {
+        IUnknown_AddRef(iface);
+        *out = iface;
+        return S_OK;
+    }
+
+    if (IsEqualGUID(iid, &IID_ISpeechRecognitionListConstraintFactory))
+    {
+        IUnknown_AddRef(iface);
+        *out = &impl->ISpeechRecognitionListConstraintFactory_iface;
+        return S_OK;
+    }
+
+    FIXME("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG STDMETHODCALLTYPE activation_factory_AddRef(
+    IActivationFactory *iface)
+{
+    struct activation_factory *impl = impl_from_IActivationFactory(iface);
+    ULONG ref = InterlockedIncrement(&impl->ref);
+    TRACE("iface %p, ref %u.\n", iface, ref);
+    return ref;
+}
+
+static ULONG STDMETHODCALLTYPE activation_factory_Release(
+    IActivationFactory *iface)
+{
+    struct activation_factory *impl = impl_from_IActivationFactory(iface);
+    ULONG ref = InterlockedDecrement(&impl->ref);
+    TRACE("iface %p, ref %u.\n", iface, ref);
+    return ref;
+}
+
+static HRESULT STDMETHODCALLTYPE activation_factory_GetIids(
+    IActivationFactory *iface, ULONG *iid_count, IID **iids)
+{
+    FIXME("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE activation_factory_GetRuntimeClassName(
+    IActivationFactory *iface, HSTRING *class_name)
+{
+    FIXME("iface %p, class_name %p stub!\n", iface, class_name);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE activation_factory_GetTrustLevel(
+    IActivationFactory *iface, TrustLevel *trust_level)
+{
+    FIXME("iface %p, trust_level %p stub!\n", iface, trust_level);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE activation_factory_ActivateInstance(
+    IActivationFactory *iface, IInspectable **instance)
+{
+    TRACE("iface %p, instance %p\n", iface, instance);
+
+    if (!instance)
+        return E_INVALIDARG;
+
+    return E_NOTIMPL;
+}
+
+static const struct IActivationFactoryVtbl activation_factory_vtbl =
+{
+        /* IUnknown methods */
+        activation_factory_QueryInterface,
+        activation_factory_AddRef,
+        activation_factory_Release,
+        /* IInspectable methods */
+        activation_factory_GetIids,
+        activation_factory_GetRuntimeClassName,
+        activation_factory_GetTrustLevel,
+        /* IActivationFactory methods */
+        activation_factory_ActivateInstance,
+};
+
+/*
+ *
+ * ISpeechRecognitionListConstraintFactory
+ *
+ */
+
+static inline struct activation_factory *impl_from_ISpeechRecognitionListConstraintFactory(ISpeechRecognitionListConstraintFactory *iface)
+{
+    return CONTAINING_RECORD(iface, struct activation_factory, ISpeechRecognitionListConstraintFactory_iface);
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_list_constraint_factory_QueryInterface(
+    ISpeechRecognitionListConstraintFactory *iface, REFIID iid, void **out)
+{
+    struct activation_factory *impl = impl_from_ISpeechRecognitionListConstraintFactory(iface);
+
+    TRACE("iface %p, iid %s, out %p stub!\n", iface, debugstr_guid(iid), out);
+
+    /* IUnknown_QueryInterface already defined by IActivationFactory_iface. Redirect there. */
+    return IActivationFactory_QueryInterface(&impl->IActivationFactory_iface, iid, out);
+}
+
+static ULONG STDMETHODCALLTYPE speech_recognition_list_constraint_factory_AddRef(
+    ISpeechRecognitionListConstraintFactory *iface)
+{
+    struct activation_factory *impl = impl_from_ISpeechRecognitionListConstraintFactory(iface);
+
+    TRACE("iface %p\n", iface);
+
+    /* IUnknown_AddRef already defined by IActivationFactory_iface. Redirect there. */
+    return IActivationFactory_AddRef(&impl->IActivationFactory_iface);
+}
+
+static ULONG STDMETHODCALLTYPE speech_recognition_list_constraint_factory_Release(
+    ISpeechRecognitionListConstraintFactory *iface)
+{
+    struct activation_factory *impl = impl_from_ISpeechRecognitionListConstraintFactory(iface);
+
+    TRACE("iface %p\n", iface);
+
+    /* IUnknown_Release already defined by IActivationFactory_iface. Redirect there. */
+    return IActivationFactory_Release(&impl->IActivationFactory_iface);
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_list_constraint_factory_GetIids(
+    ISpeechRecognitionListConstraintFactory *iface, ULONG *iid_count, IID **iids)
+{
+    struct activation_factory *impl = impl_from_ISpeechRecognitionListConstraintFactory(iface);
+
+    TRACE("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
+
+    /* IInspectable_GetIids already defined by ISpeechRecognizer_iface. Redirect there. */
+    return IActivationFactory_GetIids(&impl->IActivationFactory_iface, iid_count, iids);
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_list_constraint_factory_GetRuntimeClassName(
+    ISpeechRecognitionListConstraintFactory *iface, HSTRING *class_name)
+{
+    struct activation_factory *impl = impl_from_ISpeechRecognitionListConstraintFactory(iface);
+
+    TRACE("iface %p, class_name %p stub!\n", iface, class_name);
+
+    /* IInspectable_GetRuntimeClassName already defined by IActivationFactory_iface. Redirect there. */
+    return IActivationFactory_GetRuntimeClassName(&impl->IActivationFactory_iface, class_name);
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_list_constraint_factory_GetTrustLevel(
+    ISpeechRecognitionListConstraintFactory *iface, TrustLevel *trust_level)
+{
+    struct activation_factory *impl = impl_from_ISpeechRecognitionListConstraintFactory(iface);
+
+    TRACE("iface %p, trust_level %p stub!\n", iface, trust_level);
+
+    /* IInspectable_GetTrustLevel already defined by IActivationFactory_iface. Redirect there. */
+    return IActivationFactory_GetTrustLevel(&impl->IActivationFactory_iface, trust_level);
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_list_constraint_factory_Create(
+    ISpeechRecognitionListConstraintFactory *iface,
+    IIterable_HSTRING *commands,
+    ISpeechRecognitionListConstraint** listconstraint)
+{
+    TRACE("iface %p, commands %p, listconstraint %p.\n", iface, commands, listconstraint);
+
+    return speech_recognition_list_constraint_create(commands, listconstraint);
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_list_constraint_factory_CreateWithTag(
+    ISpeechRecognitionListConstraintFactory *iface,
+    IIterable_HSTRING *commands,
+    HSTRING tag,
+    ISpeechRecognitionListConstraint** listconstraint)
+{
+    TRACE("iface %p, commands %p, tag %p, listconstraint %p.\n", iface, commands, tag, listconstraint);
+
+    return speech_recognition_list_constraint_create_with_tag(commands, tag, listconstraint);
+}
+
+static const struct ISpeechRecognitionListConstraintFactoryVtbl speech_recognition_list_constraint_factory_vtbl =
+{
+        /* IUnknown methods */
+        speech_recognition_list_constraint_factory_QueryInterface,
+        speech_recognition_list_constraint_factory_AddRef,
+        speech_recognition_list_constraint_factory_Release,
+        /* IInspectable methods */
+        speech_recognition_list_constraint_factory_GetIids,
+        speech_recognition_list_constraint_factory_GetRuntimeClassName,
+        speech_recognition_list_constraint_factory_GetTrustLevel,
+        /* ISpeechRecognitionListConstraintFactory methods */
+        speech_recognition_list_constraint_factory_Create,
+        speech_recognition_list_constraint_factory_CreateWithTag,
+};
+
+/*
+ *
+ * ActivationFactory instances
+ *
+ */
+
+static struct activation_factory speech_recognition_list_constraint_af =
+{
+    .IActivationFactory_iface = {&activation_factory_vtbl},
+    .ISpeechRecognitionListConstraintFactory_iface = {&speech_recognition_list_constraint_factory_vtbl},
+    .ref = 1
+};
+
+void STDMETHODCALLTYPE speech_recognition_list_constraint_get_activation_factory(IActivationFactory **factory)
+{
+    *factory = &speech_recognition_list_constraint_af.IActivationFactory_iface;
+}
diff --git a/dlls/windows.media.speech/tests/speech.c b/dlls/windows.media.speech/tests/speech.c
index 682a9e555cb..6157321763e 100644
--- a/dlls/windows.media.speech/tests/speech.c
+++ b/dlls/windows.media.speech/tests/speech.c
@@ -42,6 +42,8 @@
 
 HRESULT WINAPI (*pDllGetActivationFactory)(HSTRING, IActivationFactory **);
 
+static BOOL isWin10_1507 = FALSE;
+
 static inline const char *debugstr_hstring(HSTRING hstr)
 {
     const WCHAR *str;
@@ -51,6 +53,235 @@ static inline const char *debugstr_hstring(HSTRING hstr)
     return wine_dbgstr_wn(str, len);
 }
 
+struct iterator_hstring
+{
+    IIterator_HSTRING IIterator_HSTRING_iface;
+    LONG ref;
+
+    ULONG current_item;
+    ULONG count;
+    HSTRING *values;
+};
+
+static inline struct iterator_hstring *impl_from_IIterator_HSTRING(IIterator_HSTRING *iface)
+{
+    return CONTAINING_RECORD(iface, struct iterator_hstring, IIterator_HSTRING_iface);
+}
+
+static HRESULT STDMETHODCALLTYPE iterator_hstring_QueryInterface(
+    IIterator_HSTRING *iface, REFIID iid, void **out)
+{
+    if (IsEqualGUID(iid, &IID_IUnknown) ||
+        IsEqualGUID(iid, &IID_IInspectable) ||
+        IsEqualGUID(iid, &IID_IAgileObject) ||
+        IsEqualGUID(iid, &IID_IIterator_HSTRING))
+    {
+        IUnknown_AddRef(iface);
+        *out = iface;
+        return S_OK;
+    }
+
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG STDMETHODCALLTYPE iterator_hstring_AddRef(IIterator_HSTRING *iface)
+{
+    struct iterator_hstring *impl = impl_from_IIterator_HSTRING(iface);
+
+    ULONG ref = InterlockedIncrement(&impl->ref);
+
+    return ref;
+}
+
+static ULONG STDMETHODCALLTYPE iterator_hstring_Release(IIterator_HSTRING *iface)
+{
+    struct iterator_hstring *impl = impl_from_IIterator_HSTRING(iface);
+
+    ULONG ref = InterlockedDecrement(&impl->ref);
+
+    return ref;
+}
+
+static HRESULT STDMETHODCALLTYPE iterator_hstring_GetIids(
+    IIterator_HSTRING *iface, ULONG *iid_count, IID **iids)
+{
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE iterator_hstring_GetRuntimeClassName(
+    IIterator_HSTRING *iface, HSTRING *class_name)
+{
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE iterator_hstring_GetTrustLevel(
+    IIterator_HSTRING *iface, TrustLevel *trust_level)
+{
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE iterator_hstring_get_Current(
+    IIterator_HSTRING *iface, HSTRING *value)
+{
+    struct iterator_hstring *impl = impl_from_IIterator_HSTRING(iface);
+    HRESULT hr;
+
+    if (impl->current_item >= impl->count)
+        return E_BOUNDS;
+
+    hr = WindowsDuplicateString(impl->values[impl->current_item], value);
+
+    return hr;
+}
+
+static HRESULT STDMETHODCALLTYPE iterator_hstring_get_HasCurrent(
+    IIterator_HSTRING *iface, BOOL *value)
+{
+    struct iterator_hstring *impl = impl_from_IIterator_HSTRING(iface);
+
+    *value = impl->current_item >= impl->count ? FALSE : TRUE;
+
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE iterator_hstring_MoveNext(
+    IIterator_HSTRING *iface, BOOL *value)
+{
+    struct iterator_hstring *impl = impl_from_IIterator_HSTRING(iface);
+
+    if (impl->current_item >= impl->count)
+    {
+        *value = FALSE;
+        return E_BOUNDS;
+    }
+
+    impl->current_item++;
+    *value = impl->current_item >= impl->count ? FALSE : TRUE;
+
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE iterator_hstring_GetMany(
+    IIterator_HSTRING *iface, UINT32 start_index, UINT32 items_size, HSTRING *items, UINT *count)
+{
+    return E_NOTIMPL;
+}
+
+static const struct IIterator_HSTRINGVtbl iterator_hstring_vtbl =
+{
+        iterator_hstring_QueryInterface,
+        iterator_hstring_AddRef,
+        iterator_hstring_Release,
+        /* IInspectable methods */
+        iterator_hstring_GetIids,
+        iterator_hstring_GetRuntimeClassName,
+        iterator_hstring_GetTrustLevel,
+        /* IIterator<HSTRING> methods */
+        iterator_hstring_get_Current,
+        iterator_hstring_get_HasCurrent,
+        iterator_hstring_MoveNext,
+        iterator_hstring_GetMany,
+};
+
+struct iterable_hstring
+{
+    IIterable_HSTRING IIterable_HSTRING_iface;
+    LONG ref;
+
+    IIterator_HSTRING *iterator;
+};
+
+static inline struct iterable_hstring *impl_from_Iterable_HSTRING(IIterable_HSTRING *iface)
+{
+    return CONTAINING_RECORD(iface, struct iterable_hstring, IIterable_HSTRING_iface);
+}
+
+static HRESULT STDMETHODCALLTYPE iterable_hstring_QueryInterface(
+    IIterable_HSTRING *iface, REFIID iid, void **out)
+{
+    trace("iface %p, iid %s, out %p stub!\n", iface, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IUnknown) ||
+        IsEqualGUID(iid, &IID_IInspectable) ||
+        IsEqualGUID(iid, &IID_IAgileObject) ||
+        IsEqualGUID(iid, &IID_IIterable_HSTRING))
+    {
+        IUnknown_AddRef(iface);
+        *out = iface;
+        return S_OK;
+    }
+
+    trace("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG STDMETHODCALLTYPE iterable_hstring_AddRef(IIterable_HSTRING *iface)
+{
+    struct iterable_hstring *impl = impl_from_Iterable_HSTRING(iface);
+    ULONG ref = InterlockedIncrement(&impl->ref);
+    trace("iface %p, ref %u.\n", iface, ref);
+    return ref;
+}
+
+static ULONG STDMETHODCALLTYPE iterable_hstring_Release(IIterable_HSTRING *iface)
+{
+    struct iterable_hstring *impl = impl_from_Iterable_HSTRING(iface);
+
+    ULONG ref = InterlockedDecrement(&impl->ref);
+    trace("iface %p, ref %u.\n", iface, ref);
+
+    return ref;
+}
+
+static HRESULT STDMETHODCALLTYPE iterable_hstring_GetIids(
+    IIterable_HSTRING *iface, ULONG *iid_count, IID **iids)
+{
+    trace("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE iterable_hstring_GetRuntimeClassName(
+    IIterable_HSTRING *iface, HSTRING *class_name)
+{
+    trace("iface %p, class_name %p stub!\n", iface, class_name);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE iterable_hstring_GetTrustLevel(
+    IIterable_HSTRING *iface, TrustLevel *trust_level)
+{
+    trace("iface %p, trust_level %p stub!\n", iface, trust_level);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE iterable_hstring_First(
+    IIterable_HSTRING *iface, IIterator_HSTRING **value)
+{
+    struct iterable_hstring *impl = impl_from_Iterable_HSTRING(iface);
+
+    trace("iface %p, value %p.\n", iface, value);
+
+    *value = impl->iterator;
+    IIterator_HSTRING_AddRef(*value);
+
+    return S_OK;
+}
+
+static const struct IIterable_HSTRINGVtbl iterable_hstring_vtbl =
+{
+    iterable_hstring_QueryInterface,
+    iterable_hstring_AddRef,
+    iterable_hstring_Release,
+    /* IInspectable methods */
+    iterable_hstring_GetIids,
+    iterable_hstring_GetRuntimeClassName,
+    iterable_hstring_GetTrustLevel,
+    /* IIterable<HSTRING> methods */
+    iterable_hstring_First
+};
+
 static void test_ActivationFactory(void)
 {
     static const WCHAR *speech_synthesizer_name = L"Windows.Media.SpeechSynthesis.SpeechSynthesizer";
@@ -123,6 +354,7 @@ static void test_ActivationFactory(void)
             ref = ISpeechRecognizerStatics2_Release(sr_statics2);
             ok(ref == 2, "Got unexpected refcount: %u.\n", ref);
         }
+        else isWin10_1507 = TRUE;
 
         hr = IActivationFactory_QueryInterface(afactory4, &IID_IInstalledVoicesStatic, (void**)&installed_voices);
         ok(hr == E_NOINTERFACE, "IActivationFactory_QueryInterface failed, hr %#x.\n", hr);
@@ -416,10 +648,122 @@ done:
     RoUninitialize();
 }
 
+static void test_SpeechRecognitionListConstraint(void)
+{
+    static const WCHAR *speech_recognition_list_constraint_name = L"Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint";
+    static const WCHAR *speech_constraints[] = { L"This is a test.", L"Number 5!", L"What time is it?" };
+    static const WCHAR *speech_constraint_tag = L"test_message";
+    ISpeechRecognitionListConstraintFactory *listconstraint_factory = NULL;
+    ISpeechRecognitionListConstraint *listconstraint = NULL;
+    ISpeechRecognitionConstraint *constraint = NULL;
+    struct iterator_hstring iterator_hstring;
+    struct iterable_hstring iterable_hstring;
+    IActivationFactory *factory = NULL;
+    IInspectable *inspectable = NULL;
+    HSTRING commands[3];
+    HSTRING str, tag;
+    HRESULT hr;
+    UINT32 i;
+    LONG ref;
+
+    hr = RoInitialize(RO_INIT_MULTITHREADED);
+    ok(hr == S_OK, "RoInitialize failed, hr %#x.\n", hr);
+
+    hr = WindowsCreateString(speech_recognition_list_constraint_name, wcslen(speech_recognition_list_constraint_name), &str);
+    ok(hr == S_OK, "WindowsCreateString failed, hr %#x.\n", hr);
+
+    hr = WindowsCreateString(speech_constraint_tag, wcslen(speech_constraint_tag), &tag);
+    ok(hr == S_OK, "WindowsCreateString failed, hr %#x.\n", hr);
+
+    for (i = 0; i < ARRAY_SIZE(commands); i++)
+    {
+        hr = WindowsCreateString(speech_constraints[i], wcslen(speech_constraints[i]), &commands[i]);
+        ok(hr == S_OK, "WindowsCreateString failed, hr %#x.\n", hr);
+    }
+
+    hr = RoGetActivationFactory(str, &IID_IActivationFactory, (void **)&factory);
+    ok(hr == S_OK || broken(hr == REGDB_E_CLASSNOTREG), "RoGetActivationFactory failed, hr %#x.\n", hr);
+
+    if (hr == REGDB_E_CLASSNOTREG) /* Win 8 and 8.1 */
+    {
+        win_skip("SpeechRecognitionListConstraint activation factory not available!\n");
+        goto done;
+    }
+
+    hr = IActivationFactory_ActivateInstance(factory, &inspectable);
+    ok(hr == E_NOTIMPL, "IActivationFactory_ActivateInstance failed, hr %#x.\n", hr);
+
+    hr = IActivationFactory_QueryInterface(factory, &IID_ISpeechRecognitionListConstraintFactory, (void **)&listconstraint_factory);
+    ok(hr == S_OK, "IActivationFactory_QueryInterface IID_ISpeechRecognitionListConstraintFactory failed, hr %#x.\n", hr);
+
+    hr = ISpeechRecognitionListConstraintFactory_Create(listconstraint_factory, NULL, &listconstraint);
+    ok(hr == E_POINTER, "ISpeechRecognitionListConstraintFactory_Create failed, hr %#x.\n", hr);
+
+    hr = ISpeechRecognitionListConstraintFactory_CreateWithTag(listconstraint_factory, NULL, NULL, &listconstraint);
+    ok(hr == E_POINTER, "ISpeechRecognitionListConstraintFactory_Create failed, hr %#x.\n", hr);
+
+    /* The create functions on Win10 1507 x32 break when handling the iterator. Seems like a Windows bug. Skipping these tests. */
+    if(isWin10_1507)
+    {
+        win_skip("SpeechRecognitionListConstraint create tests broken on Win10 1507!\n");
+        goto skip_create;
+    } 
+
+    iterator_hstring.IIterator_HSTRING_iface.lpVtbl = &iterator_hstring_vtbl;
+    iterator_hstring.ref = 1;
+    iterator_hstring.current_item = 0;
+    iterator_hstring.count = 3;
+    iterator_hstring.values = commands;
+
+    iterable_hstring.IIterable_HSTRING_iface.lpVtbl = &iterable_hstring_vtbl;
+    iterable_hstring.ref = 1;
+    iterable_hstring.iterator = &iterator_hstring.IIterator_HSTRING_iface;
+
+    hr = ISpeechRecognitionListConstraintFactory_CreateWithTag(listconstraint_factory, &iterable_hstring.IIterable_HSTRING_iface, NULL, &listconstraint);
+    ok(hr == S_OK, "ISpeechRecognitionListConstraintFactory_Create failed, hr %#x.\n", hr);
+
+    ref = ISpeechRecognitionListConstraint_Release(listconstraint);
+    ok(ref == 0, "Got unexpected ref %u.\n", ref);
+
+    iterator_hstring.current_item = 0;
+    iterator_hstring.count = 3;
+    iterator_hstring.values = commands;
+
+    iterable_hstring.iterator = &iterator_hstring.IIterator_HSTRING_iface;
+
+    hr = ISpeechRecognitionListConstraintFactory_CreateWithTag(listconstraint_factory, &iterable_hstring.IIterable_HSTRING_iface, tag, &listconstraint);
+    ok(hr == S_OK, "ISpeechRecognitionListConstraintFactory_CreateWithTag failed, hr %#x.\n", hr);
+
+    hr = ISpeechRecognitionListConstraint_QueryInterface(listconstraint, &IID_ISpeechRecognitionConstraint, (void **)&constraint);
+    ok(hr == S_OK, "Got unexpected hr %#x.\n", hr);
+
+    ref = ISpeechRecognitionConstraint_Release(constraint);
+    ok(ref == 1, "Got unexpected ref %u.\n", ref);
+
+    ref = ISpeechRecognitionListConstraint_Release(listconstraint);
+    ok(ref == 0, "Got unexpected ref %u.\n", ref);
+
+skip_create:
+    ref = ISpeechRecognitionListConstraintFactory_Release(listconstraint_factory);
+    ok(ref == 2, "Got unexpected ref %u.\n", ref);
+
+    ref = IActivationFactory_Release(factory);
+    ok(ref == 1, "Got unexpected ref %u.\n", ref);
+
+done:
+    WindowsDeleteString(str);
+    WindowsDeleteString(tag);
+    for (i = 0; i < ARRAY_SIZE(commands); i++)
+        WindowsDeleteString(commands[i]);
+
+    RoUninitialize();
+}
+
 START_TEST(speech)
 {
     test_ActivationFactory();
     test_SpeechSynthesizer();
     test_VoiceInformation();
     test_SpeechRecognizer();
+    test_SpeechRecognitionListConstraint();
 }
diff --git a/dlls/windows.media.speech/windows_media_speech_private.h b/dlls/windows.media.speech/windows_media_speech_private.h
index b25002b2cbc..06ea55b423d 100644
--- a/dlls/windows.media.speech/windows_media_speech_private.h
+++ b/dlls/windows.media.speech/windows_media_speech_private.h
@@ -64,6 +64,7 @@ static inline const char *debugstr_hstring(HSTRING hstr)
  *
  */
 
+void STDMETHODCALLTYPE speech_recognition_list_constraint_get_activation_factory(IActivationFactory **factory) DECLSPEC_HIDDEN;
 void STDMETHODCALLTYPE speech_recognizer_get_activation_factory(IActivationFactory **factory) DECLSPEC_HIDDEN;
 
 /*
-- 
2.34.1

