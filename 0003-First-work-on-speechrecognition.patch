From a0f52a2b4ebfca78398ecb1b6f3e88ba692b284d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Bernhard=20K=C3=B6lbl?= <besentv@gmail.com>
Date: Sat, 18 Dec 2021 19:08:04 +0100
Subject: [PATCH 3/3] First work on speechrecognition.

---
 WinRT-Coding-Guideline.txt                    |  14 +
 dlls/windows.media.speech/Makefile.in         |   4 +-
 dlls/windows.media.speech/classes.idl         |   1 +
 dlls/windows.media.speech/main.c              | 585 ++-----------
 dlls/windows.media.speech/speechrecognition.c | 788 ++++++++++++++++++
 dlls/windows.media.speech/speechsynthesis.c   | 497 +++++++++++
 .../windows_media_speech_private.h            |  86 ++
 include/Makefile.in                           |   1 +
 include/windows.foundation.idl                |   9 +
 include/windows.globalization.idl             |  42 +
 include/windows.media.speechrecognition.idl   | 445 ++++++++++
 include/windows.media.speechsynthesis.idl     |   3 +-
 12 files changed, 1975 insertions(+), 500 deletions(-)
 create mode 100644 WinRT-Coding-Guideline.txt
 create mode 100644 dlls/windows.media.speech/speechrecognition.c
 create mode 100644 dlls/windows.media.speech/speechsynthesis.c
 create mode 100644 dlls/windows.media.speech/windows_media_speech_private.h
 create mode 100644 include/windows.media.speechrecognition.idl

diff --git a/WinRT-Coding-Guideline.txt b/WinRT-Coding-Guideline.txt
new file mode 100644
index 00000000000..e892064d44d
--- /dev/null
+++ b/WinRT-Coding-Guideline.txt
@@ -0,0 +1,14 @@
+WinRT coding rules:
+
+-Use WIDL using defines like usings in C++ -> i.e only put them in the file where you need them.
+
+-Always name the parameter in a property "value".
+-Always name vtables "i_<name of interface>_vtbl".
+-Put everything from one namespace into the same file.
+    E.g.
+        -> Windows.Media.SpeechRecognition in ./dlls/windows.media.speech/speechrecognition.c
+        -> Windows.Media.SpeechSynthesis in ./dlls/windows.media.speech/speechsynthesis.c
+
+-Max Line length 130.
+-Indent 8 spaces when a statement goes over 2+ lines.
+-Only create one pair of brackets for multiple tags. E.g. [out, retval] not [out] [retval] 
\ No newline at end of file
diff --git a/dlls/windows.media.speech/Makefile.in b/dlls/windows.media.speech/Makefile.in
index 9fbff8e132f..04ea5c01f55 100644
--- a/dlls/windows.media.speech/Makefile.in
+++ b/dlls/windows.media.speech/Makefile.in
@@ -2,6 +2,8 @@ MODULE = windows.media.speech.dll
 IMPORTS = combase uuid
 
 C_SRCS = \
-	main.c
+	main.c \
+	speechrecognition.c \
+	speechsynthesis.c
 
 IDL_SRCS = classes.idl
diff --git a/dlls/windows.media.speech/classes.idl b/dlls/windows.media.speech/classes.idl
index 6c141bf4768..4dd43cf6eed 100644
--- a/dlls/windows.media.speech/classes.idl
+++ b/dlls/windows.media.speech/classes.idl
@@ -16,4 +16,5 @@
 
 #pragma makedep register
 
+#include "windows.media.speechrecognition.idl"
 #include "windows.media.speechsynthesis.idl"
diff --git a/dlls/windows.media.speech/main.c b/dlls/windows.media.speech/main.c
index b607f9a8203..70c69a0f31d 100644
--- a/dlls/windows.media.speech/main.c
+++ b/dlls/windows.media.speech/main.c
@@ -17,401 +17,30 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
-#include <stdarg.h>
+#define WINDOWS_MEDIA_SPEECH_INIT_GUID
 
-#define COBJMACROS
-#include "windef.h"
-#include "winbase.h"
-#include "winstring.h"
-#include "wine/debug.h"
-#include "objbase.h"
-
-#include "initguid.h"
-#include "activation.h"
-
-#define WIDL_using_Windows_Foundation
-#define WIDL_using_Windows_Foundation_Collections
-#include "windows.foundation.h"
-#define WIDL_using_Windows_Media_SpeechSynthesis
-#include "windows.media.speechsynthesis.h"
+#include "windows_media_speech_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(speech);
 
-static const char *debugstr_hstring(HSTRING hstr)
-{
-    const WCHAR *str;
-    UINT32 len;
-    if (hstr && !((ULONG_PTR)hstr >> 16)) return "(invalid)";
-    str = WindowsGetStringRawBuffer(hstr, &len);
-    return wine_dbgstr_wn(str, len);
-}
-
-struct voice_information_vector
-{
-    IVectorView_VoiceInformation IVectorView_VoiceInformation_iface;
-    LONG ref;
-};
-
-static inline struct voice_information_vector *impl_from_IVectorView_VoiceInformation(IVectorView_VoiceInformation *iface)
-{
-    return CONTAINING_RECORD(iface, struct voice_information_vector, IVectorView_VoiceInformation_iface);
-}
-
-static HRESULT STDMETHODCALLTYPE vector_view_voice_information_QueryInterface(
-        IVectorView_VoiceInformation *iface, REFIID iid, void **out)
-{
-    TRACE("iface %p, iid %s, out %p stub!\n", iface, debugstr_guid(iid), out);
-
-    if (IsEqualGUID(iid, &IID_IUnknown) ||
-        IsEqualGUID(iid, &IID_IInspectable) ||
-        IsEqualGUID(iid, &IID_IVectorView_VoiceInformation))
-    {
-        IUnknown_AddRef(iface);
-        *out = iface;
-        return S_OK;
-    }
-
-    WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
-    *out = NULL;
-    return E_NOINTERFACE;
-}
-
-static ULONG STDMETHODCALLTYPE vector_view_voice_information_AddRef(
-        IVectorView_VoiceInformation *iface)
-{
-    struct voice_information_vector *impl = impl_from_IVectorView_VoiceInformation(iface);
-    ULONG ref = InterlockedIncrement(&impl->ref);
-    TRACE("iface %p, ref %u.\n", iface, ref);
-    return ref;
-}
-
-static ULONG STDMETHODCALLTYPE vector_view_voice_information_Release(
-        IVectorView_VoiceInformation *iface)
-{
-    struct voice_information_vector *impl = impl_from_IVectorView_VoiceInformation(iface);
-    ULONG ref = InterlockedDecrement(&impl->ref);
-    TRACE("iface %p, ref %u.\n", iface, ref);
-    return ref;
-}
-
-static HRESULT STDMETHODCALLTYPE vector_view_voice_information_GetIids(
-        IVectorView_VoiceInformation *iface, ULONG *iid_count, IID **iids)
-{
-    FIXME("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
-    return E_NOTIMPL;
-}
-
-static HRESULT STDMETHODCALLTYPE vector_view_voice_information_GetRuntimeClassName(
-        IVectorView_VoiceInformation *iface, HSTRING *class_name)
-{
-    FIXME("iface %p, class_name %p stub!\n", iface, class_name);
-    return E_NOTIMPL;
-}
-
-static HRESULT STDMETHODCALLTYPE vector_view_voice_information_GetTrustLevel(
-        IVectorView_VoiceInformation *iface, TrustLevel *trust_level)
-{
-    FIXME("iface %p, trust_level %p stub!\n", iface, trust_level);
-    return E_NOTIMPL;
-}
-
-static HRESULT STDMETHODCALLTYPE vector_view_voice_information_GetAt(
-        IVectorView_VoiceInformation *iface, UINT32 index, IVoiceInformation **value)
-{
-    FIXME("iface %p, index %#x, value %p stub!\n", iface, index, value);
-    *value = NULL;
-    return E_BOUNDS;
-}
-
-static HRESULT STDMETHODCALLTYPE vector_view_voice_information_get_Size(
-        IVectorView_VoiceInformation *iface, UINT32 *value)
-{
-    FIXME("iface %p, value %p stub!\n", iface, value);
-    *value = 0;
-    return S_OK;
-}
-
-static HRESULT STDMETHODCALLTYPE vector_view_voice_information_IndexOf(
-        IVectorView_VoiceInformation *iface, IVoiceInformation *element, UINT32 *index, BOOLEAN *found)
-{
-    FIXME("iface %p, element %p, index %p, found %p stub!\n", iface, element, index, found);
-    *index = 0;
-    *found = FALSE;
-    return S_OK;
-}
-
-static HRESULT STDMETHODCALLTYPE vector_view_voice_information_GetMany(
-        IVectorView_VoiceInformation *iface, UINT32 start_index,
-        UINT32 items_size, IVoiceInformation **items, UINT *value)
-{
-    FIXME("iface %p, start_index %#x, items %p, value %p stub!\n", iface, start_index, items, value);
-    *value = 0;
-    return S_OK;
-}
-
-static const struct IVectorView_VoiceInformationVtbl vector_view_voice_information_vtbl =
-{
-    vector_view_voice_information_QueryInterface,
-    vector_view_voice_information_AddRef,
-    vector_view_voice_information_Release,
-    /* IInspectable methods */
-    vector_view_voice_information_GetIids,
-    vector_view_voice_information_GetRuntimeClassName,
-    vector_view_voice_information_GetTrustLevel,
-    /* IVectorView<VoiceInformation> methods */
-    vector_view_voice_information_GetAt,
-    vector_view_voice_information_get_Size,
-    vector_view_voice_information_IndexOf,
-    vector_view_voice_information_GetMany,
-};
-
-static struct voice_information_vector all_voices =
-{
-    {&vector_view_voice_information_vtbl},
-    0
-};
-
-struct speech_synthesizer
-{
-    ISpeechSynthesizer ISpeechSynthesizer_iface;
-    IClosable IClosable_iface;
-    LONG ref;
-};
-
-static inline struct speech_synthesizer *impl_from_ISpeechSynthesizer(ISpeechSynthesizer *iface)
-{
-    return CONTAINING_RECORD(iface, struct speech_synthesizer, ISpeechSynthesizer_iface);
-}
-
-static inline struct speech_synthesizer *impl_from_IClosable(IClosable *iface)
-{
-    return CONTAINING_RECORD(iface, struct speech_synthesizer, IClosable_iface);
-}
-
-static HRESULT STDMETHODCALLTYPE speech_synthesizer_QueryInterface(
-        ISpeechSynthesizer *iface, REFIID iid, void **out)
-{
-    struct speech_synthesizer *impl = impl_from_ISpeechSynthesizer(iface);
-
-    TRACE("iface %p, iid %s, out %p stub!\n", iface, debugstr_guid(iid), out);
-
-    if (IsEqualGUID(iid, &IID_IUnknown) ||
-        IsEqualGUID(iid, &IID_IInspectable) ||
-        IsEqualGUID(iid, &IID_ISpeechSynthesizer))
-    {
-        IUnknown_AddRef(iface);
-        *out = iface;
-        return S_OK;
-    }
-
-    if (IsEqualGUID(iid, &IID_IClosable))
-    {
-        IUnknown_AddRef(iface);
-        *out = &impl->IClosable_iface;
-        return S_OK;
-    }
-
-    FIXME("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
-    *out = NULL;
-    return E_NOINTERFACE;
-}
-
-static ULONG STDMETHODCALLTYPE speech_synthesizer_AddRef(
-        ISpeechSynthesizer *iface)
-{
-    struct speech_synthesizer *impl = impl_from_ISpeechSynthesizer(iface);
-    ULONG ref = InterlockedIncrement(&impl->ref);
-
-    TRACE("iface %p, ref %u.\n", iface, ref);
-
-    return ref;
-}
-
-static ULONG STDMETHODCALLTYPE speech_synthesizer_Release(
-        ISpeechSynthesizer *iface)
-{
-    struct speech_synthesizer *impl = impl_from_ISpeechSynthesizer(iface);
-    ULONG ref = InterlockedDecrement(&impl->ref);
-
-    TRACE("iface %p, ref %u.\n", iface, ref);
-
-    if (!ref)
-        free(impl);
-
-    return ref;
-}
-
-static HRESULT STDMETHODCALLTYPE speech_synthesizer_GetIids(
-        ISpeechSynthesizer *iface, ULONG *iid_count, IID **iids)
-{
-    FIXME("iface %p, iid_count %p, iids %p stub.\n", iface, iid_count, iids);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT STDMETHODCALLTYPE speech_synthesizer_GetRuntimeClassName(
-        ISpeechSynthesizer *iface, HSTRING *class_name)
-{
-    FIXME("iface %p, class_name %p stub.\n", iface, class_name);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT STDMETHODCALLTYPE speech_synthesizer_GetTrustLevel(
-        ISpeechSynthesizer *iface, TrustLevel *trust_level)
-{
-    FIXME("iface %p, trust_level %p stub.\n", iface, trust_level);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT STDMETHODCALLTYPE speech_synthesizer_SynthesizeTextToStreamAsync(ISpeechSynthesizer *iface,
-        HSTRING text, IAsyncOperation_SpeechSynthesisStream **operation)
-{
-    FIXME("iface %p, text %p, operation %p stub.\n", iface, text, operation);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT STDMETHODCALLTYPE speech_synthesizer_SynthesizeSsmlToStreamAsync(ISpeechSynthesizer *iface,
-        HSTRING ssml, IAsyncOperation_SpeechSynthesisStream **operation)
-{
-    FIXME("iface %p, text %p, operation %p stub.\n", iface, ssml, operation);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT STDMETHODCALLTYPE speech_synthesizer_put_Voice(ISpeechSynthesizer *iface, IVoiceInformation *value)
-{
-    FIXME("iface %p, value %p stub.\n", iface, value);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT STDMETHODCALLTYPE speech_synthesizer_get_Voice(ISpeechSynthesizer *iface, IVoiceInformation **value)
-{
-    FIXME("iface %p, value %p stub.\n", iface, value);
-
-    return E_NOTIMPL;
-}
-
-static const struct ISpeechSynthesizerVtbl speech_synthesizer_vtbl =
-{
-    /* IUnknown methods */
-    speech_synthesizer_QueryInterface,
-    speech_synthesizer_AddRef,
-    speech_synthesizer_Release,
-    /* IInspectable methods */
-    speech_synthesizer_GetIids,
-    speech_synthesizer_GetRuntimeClassName,
-    speech_synthesizer_GetTrustLevel,
-    /* ISpeechSynthesizer methods */
-    speech_synthesizer_SynthesizeTextToStreamAsync,
-    speech_synthesizer_SynthesizeSsmlToStreamAsync,
-    speech_synthesizer_put_Voice,
-    speech_synthesizer_get_Voice,
-};
-
-static HRESULT STDMETHODCALLTYPE closable_QueryInterface(
-        IClosable *iface, REFIID iid, void **out)
-{
-    struct speech_synthesizer *impl = impl_from_IClosable(iface);
-
-    return speech_synthesizer_QueryInterface(&impl->ISpeechSynthesizer_iface, iid, out);
-}
-
-static ULONG STDMETHODCALLTYPE closable_AddRef(
-        IClosable *iface)
-{
-    struct speech_synthesizer *impl = impl_from_IClosable(iface);
-    ULONG ref = InterlockedIncrement(&impl->ref);
-
-    TRACE("iface %p, ref %u.\n", iface, ref);
-
-    return ref;
-}
-
-static ULONG STDMETHODCALLTYPE closable_Release(
-        IClosable *iface)
-{
-    struct speech_synthesizer *impl = impl_from_IClosable(iface);
-    ULONG ref = InterlockedDecrement(&impl->ref);
-
-    TRACE("iface %p, ref %u.\n", iface, ref);
-
-    if (!ref)
-        free(impl);
-
-    return ref;
-}
-
-static HRESULT STDMETHODCALLTYPE closable_GetIids(
-        IClosable *iface, ULONG *iid_count, IID **iids)
-{
-    FIXME("iface %p, iid_count %p, iids %p stub.\n", iface, iid_count, iids);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT STDMETHODCALLTYPE closable_GetRuntimeClassName(
-        IClosable *iface, HSTRING *class_name)
-{
-    FIXME("iface %p, class_name %p stub.\n", iface, class_name);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT STDMETHODCALLTYPE closable_GetTrustLevel(
-        IClosable *iface, TrustLevel *trust_level)
-{
-    FIXME("iface %p, trust_level %p stub.\n", iface, trust_level);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT STDMETHODCALLTYPE closable_Close(
-        IClosable *iface)
-{
-    FIXME("iface %p stub.\n", iface);
-
-    return E_NOTIMPL;
-}
-
-static const struct IClosableVtbl closable_vtbl =
-{
-    /* IUnknown methods */
-    closable_QueryInterface,
-    closable_AddRef,
-    closable_Release,
-    /* IInspectable methods */
-    closable_GetIids,
-    closable_GetRuntimeClassName,
-    closable_GetTrustLevel,
-    /* IClosable methods */
-    closable_Close,
-};
-
-struct windows_media_speech
+struct activation_factory
 {
     IActivationFactory IActivationFactory_iface;
-    IInstalledVoicesStatic IInstalledVoicesStatic_iface;
+    ISpeechRecognitionListConstraintFactory ISpeechRecognitionListConstraintFactory_iface;
+    ISpeechRecognizerFactory ISpeechRecognizerFactory_iface;
+    HRESULT (*create_instance)(REFIID iid, void **obj);
     LONG ref;
 };
 
-static inline struct windows_media_speech *impl_from_IActivationFactory(IActivationFactory *iface)
-{
-    return CONTAINING_RECORD(iface, struct windows_media_speech, IActivationFactory_iface);
-}
-
-static inline struct windows_media_speech *impl_from_IInstalledVoicesStatic(IInstalledVoicesStatic *iface)
+static inline struct activation_factory *impl_from_IActivationFactory(IActivationFactory *iface)
 {
-    return CONTAINING_RECORD(iface, struct windows_media_speech, IInstalledVoicesStatic_iface);
+    return CONTAINING_RECORD(iface, struct activation_factory, IActivationFactory_iface);
 }
 
-static HRESULT STDMETHODCALLTYPE windows_media_speech_QueryInterface(
-        IActivationFactory *iface, REFIID iid, void **out)
+static HRESULT STDMETHODCALLTYPE activation_factory_QueryInterface(
+    IActivationFactory *iface, REFIID iid, void **out)
 {
-    struct windows_media_speech *impl = impl_from_IActivationFactory(iface);
+    //struct activation_factory *impl = impl_from_IActivationFactory(iface);
 
     TRACE("iface %p, iid %s, out %p stub!\n", iface, debugstr_guid(iid), out);
 
@@ -425,166 +54,114 @@ static HRESULT STDMETHODCALLTYPE windows_media_speech_QueryInterface(
         return S_OK;
     }
 
-    if (IsEqualGUID(iid, &IID_IInstalledVoicesStatic))
-    {
-        IUnknown_AddRef(iface);
-        *out = &impl->IInstalledVoicesStatic_iface;
-        return S_OK;
-    }
+    // if (IsEqualGUID(iid, &IID_IInstalledVoicesStatic))
+    // {
+    //     IUnknown_AddRef(iface);
+    //     *out = &impl->IInstalledVoicesStatic_iface;
+    //     return S_OK;
+    // }
 
     FIXME("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
     *out = NULL;
     return E_NOINTERFACE;
 }
 
-static ULONG STDMETHODCALLTYPE windows_media_speech_AddRef(
-        IActivationFactory *iface)
+static ULONG STDMETHODCALLTYPE activation_factory_AddRef(
+    IActivationFactory *iface)
 {
-    struct windows_media_speech *impl = impl_from_IActivationFactory(iface);
+    struct activation_factory *impl = impl_from_IActivationFactory(iface);
     ULONG ref = InterlockedIncrement(&impl->ref);
     TRACE("iface %p, ref %u.\n", iface, ref);
     return ref;
 }
 
-static ULONG STDMETHODCALLTYPE windows_media_speech_Release(
-        IActivationFactory *iface)
+static ULONG STDMETHODCALLTYPE activation_factory_Release(
+    IActivationFactory *iface)
 {
-    struct windows_media_speech *impl = impl_from_IActivationFactory(iface);
+    struct activation_factory *impl = impl_from_IActivationFactory(iface);
     ULONG ref = InterlockedDecrement(&impl->ref);
     TRACE("iface %p, ref %u.\n", iface, ref);
     return ref;
 }
 
-static HRESULT STDMETHODCALLTYPE windows_media_speech_GetIids(
-        IActivationFactory *iface, ULONG *iid_count, IID **iids)
+static HRESULT STDMETHODCALLTYPE activation_factory_GetIids(
+    IActivationFactory *iface, ULONG *iid_count, IID **iids)
 {
     FIXME("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
     return E_NOTIMPL;
 }
 
-static HRESULT STDMETHODCALLTYPE windows_media_speech_GetRuntimeClassName(
-        IActivationFactory *iface, HSTRING *class_name)
+static HRESULT STDMETHODCALLTYPE activation_factory_GetRuntimeClassName(
+    IActivationFactory *iface, HSTRING *class_name)
 {
     FIXME("iface %p, class_name %p stub!\n", iface, class_name);
     return E_NOTIMPL;
 }
 
-static HRESULT STDMETHODCALLTYPE windows_media_speech_GetTrustLevel(
-        IActivationFactory *iface, TrustLevel *trust_level)
+static HRESULT STDMETHODCALLTYPE activation_factory_GetTrustLevel(
+    IActivationFactory *iface, TrustLevel *trust_level)
 {
     FIXME("iface %p, trust_level %p stub!\n", iface, trust_level);
     return E_NOTIMPL;
 }
 
-static HRESULT STDMETHODCALLTYPE windows_media_speech_ActivateInstance(
-        IActivationFactory *iface, IInspectable **instance)
+static HRESULT STDMETHODCALLTYPE activation_factory_ActivateInstance(
+    IActivationFactory *iface, IInspectable **instance)
 {
-    struct speech_synthesizer *obj;
+    struct activation_factory *This = impl_from_IActivationFactory(iface);
 
-    TRACE("iface %p, instance %p.\n", iface, instance);
+    TRACE("iface %p, instance %p\n", iface, instance);
 
-    if (!(obj = calloc(1, sizeof(*obj))))
+    if (!instance)
+        return E_INVALIDARG;
+
+    if (This)
     {
-        *instance = NULL;
-        return E_OUTOFMEMORY;
+        return This->create_instance(&IID_IInspectable, (void **)instance);
     }
 
-    obj->ISpeechSynthesizer_iface.lpVtbl = &speech_synthesizer_vtbl;
-    obj->IClosable_iface.lpVtbl = &closable_vtbl;
-    obj->ref = 1;
-    *instance = (IInspectable *)&obj->ISpeechSynthesizer_iface;
-    return S_OK;
+    return E_NOINTERFACE;
 }
 
 static const struct IActivationFactoryVtbl activation_factory_vtbl =
-{
-    windows_media_speech_QueryInterface,
-    windows_media_speech_AddRef,
-    windows_media_speech_Release,
-    /* IInspectable methods */
-    windows_media_speech_GetIids,
-    windows_media_speech_GetRuntimeClassName,
-    windows_media_speech_GetTrustLevel,
-    /* IActivationFactory methods */
-    windows_media_speech_ActivateInstance,
+    {
+        /* IUnknown methods */
+        activation_factory_QueryInterface,
+        activation_factory_AddRef,
+        activation_factory_Release,
+        /* IInspectable methods */
+        activation_factory_GetIids,
+        activation_factory_GetRuntimeClassName,
+        activation_factory_GetTrustLevel,
+        /* IActivationFactory methods */
+        activation_factory_ActivateInstance,
 };
 
-static HRESULT STDMETHODCALLTYPE installed_voices_static_QueryInterface(
-        IInstalledVoicesStatic *iface, REFIID iid, void **out)
-{
-    struct windows_media_speech *impl = impl_from_IInstalledVoicesStatic(iface);
-    return windows_media_speech_QueryInterface(&impl->IActivationFactory_iface, iid, out);
-}
-
-static ULONG STDMETHODCALLTYPE installed_voices_static_AddRef(
-        IInstalledVoicesStatic *iface)
-{
-    struct windows_media_speech *impl = impl_from_IInstalledVoicesStatic(iface);
-    return windows_media_speech_AddRef(&impl->IActivationFactory_iface);
-}
-
-static ULONG STDMETHODCALLTYPE installed_voices_static_Release(
-        IInstalledVoicesStatic *iface)
-{
-    struct windows_media_speech *impl = impl_from_IInstalledVoicesStatic(iface);
-    return windows_media_speech_Release(&impl->IActivationFactory_iface);
-}
+// static struct activation_factory windows_media_speech =
+// {
+//     {&activation_factory_vtbl},
+//     //{&installed_voices_static_vtbl},
+//     NULL,
+//     1
+// };
 
-static HRESULT STDMETHODCALLTYPE installed_voices_static_GetIids(
-        IInstalledVoicesStatic *iface, ULONG *iid_count, IID **iids)
+static struct activation_factory speechrecognition_speechrecognizer_af =
 {
-    FIXME("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
-    return E_NOTIMPL;
-}
-
-static HRESULT STDMETHODCALLTYPE installed_voices_static_GetRuntimeClassName(
-        IInstalledVoicesStatic *iface, HSTRING *class_name)
-{
-    FIXME("iface %p, class_name %p stub!\n", iface, class_name);
-    return E_NOTIMPL;
-}
-
-static HRESULT STDMETHODCALLTYPE installed_voices_static_GetTrustLevel(
-        IInstalledVoicesStatic *iface, TrustLevel *trust_level)
-{
-    FIXME("iface %p, trust_level %p stub!\n", iface, trust_level);
-    return E_NOTIMPL;
-}
-
-static HRESULT STDMETHODCALLTYPE installed_voices_static_get_AllVoices(
-    IInstalledVoicesStatic *iface, IVectorView_VoiceInformation **value)
-{
-    TRACE("iface %p, value %p.\n", iface, value);
-    *value = &all_voices.IVectorView_VoiceInformation_iface;
-    IVectorView_VoiceInformation_AddRef(*value);
-    return S_OK;
-}
-
-static HRESULT STDMETHODCALLTYPE installed_voices_static_get_DefaultVoice(
-    IInstalledVoicesStatic *iface, IVoiceInformation **value)
-{
-    FIXME("iface %p, value %p stub!\n", iface, value);
-    return E_NOTIMPL;
-}
-
-static const struct IInstalledVoicesStaticVtbl installed_voices_static_vtbl =
-{
-    installed_voices_static_QueryInterface,
-    installed_voices_static_AddRef,
-    installed_voices_static_Release,
-    /* IInspectable methods */
-    installed_voices_static_GetIids,
-    installed_voices_static_GetRuntimeClassName,
-    installed_voices_static_GetTrustLevel,
-    /* IInstalledVoicesStatic methods */
-    installed_voices_static_get_AllVoices,
-    installed_voices_static_get_DefaultVoice,
+    {&activation_factory_vtbl},
+    NULL,
+    NULL,
+    //{&installed_voices_static_vtbl},
+    speech_recognizer_create,
+    1
 };
 
-static struct windows_media_speech windows_media_speech =
+static struct activation_factory speechrecognition_speechrecognitionlistconstraint_af =
 {
     {&activation_factory_vtbl},
-    {&installed_voices_static_vtbl},
+    NULL,
+    NULL,
+    //{&installed_voices_static_vtbl},
+    speech_recognition_list_constraint_create,
     1
 };
 
@@ -596,15 +173,27 @@ HRESULT WINAPI DllGetClassObject(REFCLSID clsid, REFIID riid, void **out)
 
 HRESULT WINAPI DllGetActivationFactory(HSTRING classid, IActivationFactory **factory)
 {
-    TRACE("classid %s, factory %p.\n", debugstr_hstring(classid), factory);
+    TRACE("----classid %s, factory %p----.\n", debugstr_hstring(classid), factory);
 
-    if (wcscmp(WindowsGetStringRawBuffer(classid, NULL), L"Windows.Media.SpeechSynthesis.SpeechSynthesizer"))
+    if (IsEqualClassID(WindowsGetStringRawBuffer(classid, NULL), L"Windows.Media.SpeechSynthesis.SpeechSynthesizer"))
     {
-        ERR("Unknown classid %s.\n", debugstr_hstring(classid));
+        // *factory = &windows_media_speech.IActivationFactory_iface;
+        // IUnknown_AddRef(*factory);
         return CLASS_E_CLASSNOTAVAILABLE;
     }
+    else if (IsEqualClassID(WindowsGetStringRawBuffer(classid, NULL), L"Windows.Media.SpeechRecognition.SpeechRecognizer"))
+    {
+        *factory = &speechrecognition_speechrecognizer_af.IActivationFactory_iface;
+        IUnknown_AddRef(*factory);
+        return S_OK;
+    }
+    else if (IsEqualClassID(WindowsGetStringRawBuffer(classid, NULL), L"Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint"))
+    {
+        *factory = &speechrecognition_speechrecognitionlistconstraint_af.IActivationFactory_iface;
+        IUnknown_AddRef(*factory);
+        return S_OK;
+    }
 
-    *factory = &windows_media_speech.IActivationFactory_iface;
-    IUnknown_AddRef(*factory);
-    return S_OK;
+    ERR("Unknown classid %s.\n", debugstr_hstring(classid));
+    return CLASS_E_CLASSNOTAVAILABLE;
 }
diff --git a/dlls/windows.media.speech/speechrecognition.c b/dlls/windows.media.speech/speechrecognition.c
new file mode 100644
index 00000000000..f3baba30116
--- /dev/null
+++ b/dlls/windows.media.speech/speechrecognition.c
@@ -0,0 +1,788 @@
+/* WinRT Windows.Media.SpeechRecognition implementation
+ *
+ * Copyright 2021 Bernhard Kölbl
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "windows_media_speech_private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(speech);
+
+/*
+*
+* SpeechContinuousRecognitionCompletedEventArgs
+*
+*/
+
+struct speech_continuous_recognition_completed_event_args
+{
+    ISpeechContinuousRecognitionCompletedEventArgs ISpeechContinuousRecognitionCompletedEventArgs_iface;
+    LONG ref;
+};
+
+static inline struct speech_continuous_recognition_completed_event_args
+        *impl_from_ISpeechContinuousRecognitionCompletedEventArgs(
+        ISpeechContinuousRecognitionCompletedEventArgs *iface)
+{
+    return CONTAINING_RECORD(iface, struct speech_continuous_recognition_completed_event_args, ISpeechContinuousRecognitionCompletedEventArgs_iface);
+}
+
+/*
+*
+* ISpeechContinuousRecognitionCompletedEventArgs
+*
+*/
+
+#pragma region ISpeechContinuousRecognitionCompletedEventArgs
+
+static HRESULT STDMETHODCALLTYPE speech_continuous_recognition_completed_event_args_QueryInterface(
+        ISpeechContinuousRecognitionCompletedEventArgs *iface, REFIID iid, void **out)
+{
+    TRACE("iface %p, iid %s, out %p stub!\n", iface, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IUnknown) ||
+        IsEqualGUID(iid, &IID_IInspectable) ||
+        IsEqualGUID(iid, &IID_ISpeechContinuousRecognitionCompletedEventArgs))
+    {
+        IUnknown_AddRef(iface);
+        *out = iface;
+        return S_OK;
+    }
+
+
+    WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG STDMETHODCALLTYPE speech_continuous_recognition_completed_event_args_AddRef(
+        ISpeechContinuousRecognitionCompletedEventArgs *iface)
+{
+    struct speech_continuous_recognition_completed_event_args *This = impl_from_ISpeechContinuousRecognitionCompletedEventArgs(iface);
+
+    ULONG ref = InterlockedIncrement(&This->ref);
+    TRACE("iface %p, ref %u.\n", iface, ref);
+
+    return ref;
+}
+
+static ULONG STDMETHODCALLTYPE speech_continuous_recognition_completed_event_args_Release(
+        ISpeechContinuousRecognitionCompletedEventArgs *iface)
+{
+    struct speech_continuous_recognition_completed_event_args *This = impl_from_ISpeechContinuousRecognitionCompletedEventArgs(iface);
+
+    ULONG ref = InterlockedDecrement(&This->ref);
+    TRACE("iface %p, ref %u.\n", iface, ref);
+
+    if(!ref)
+        heap_free(This);
+
+    return ref;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_continuous_recognition_completed_event_args_GetIids(
+        ISpeechContinuousRecognitionCompletedEventArgs *iface, ULONG *iid_count, IID **iids)
+{
+    FIXME("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_continuous_recognition_completed_event_args_GetRuntimeClassName(
+        ISpeechContinuousRecognitionCompletedEventArgs *iface, HSTRING *class_name)
+{
+    FIXME("iface %p, class_name %p stub!\n", iface, class_name);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_continuous_recognition_completed_event_args_GetTrustLevel(
+        ISpeechContinuousRecognitionCompletedEventArgs *iface, TrustLevel *trust_level)
+{
+    FIXME("iface %p, trust_level %p stub!\n", iface, trust_level);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_continuous_recognition_completed_event_args_get_Status(
+        ISpeechContinuousRecognitionCompletedEventArgs *iface, SpeechRecognitionResultStatus *value)
+{
+    FIXME("iface %p, value %p stub!\n", iface, value);
+    *value = SpeechRecognitionResultStatus_Success;
+    return E_NOTIMPL;
+}
+
+static const struct ISpeechContinuousRecognitionCompletedEventArgsVtbl 
+        speech_continuous_recognition_completed_event_args_vtbl =
+{
+    /* IUnknown methods */
+    speech_continuous_recognition_completed_event_args_QueryInterface,
+    speech_continuous_recognition_completed_event_args_AddRef,
+    speech_continuous_recognition_completed_event_args_Release,
+    /* IInspectable methods */
+    speech_continuous_recognition_completed_event_args_GetIids,
+    speech_continuous_recognition_completed_event_args_GetRuntimeClassName,
+    speech_continuous_recognition_completed_event_args_GetTrustLevel,
+    /* ISpeechContinuousRecognitionCompletedEventArgs methods */
+    speech_continuous_recognition_completed_event_args_get_Status
+};
+
+#pragma endregion ISpeechContinuousRecognitionCompletedEventArgs
+
+HRESULT speech_continuous_recognition_completed_event_args_create(REFIID iid, void **obj)
+{
+    struct speech_continuous_recognition_completed_event_args *This;
+    HRESULT hr;
+
+    if (!(This = heap_alloc_zero(sizeof(*This))))
+        return E_OUTOFMEMORY;
+
+    This->ISpeechContinuousRecognitionCompletedEventArgs_iface.lpVtbl = &speech_continuous_recognition_completed_event_args_vtbl;
+    This->ref = 1;
+
+    hr = ISpeechContinuousRecognitionCompletedEventArgs_QueryInterface(&This->ISpeechContinuousRecognitionCompletedEventArgs_iface, iid, obj);
+    ISpeechContinuousRecognitionCompletedEventArgs_Release(&This->ISpeechContinuousRecognitionCompletedEventArgs_iface);
+
+    return hr;
+}
+
+/*
+*
+* SpeechRecognitionListConstraint
+*
+*/
+
+struct speech_recognition_list_constraint
+{
+    ISpeechRecognitionListConstraint ISpeechRecognitionListConstraint_iface;
+    ISpeechRecognitionConstraint ISpeechRecognitionConstraint_iface;
+    LONG ref;
+};
+
+static inline struct speech_recognition_list_constraint
+        *impl_from_ISpeechRecognitionListConstraint(ISpeechRecognitionListConstraint *iface)
+{
+    return CONTAINING_RECORD(iface, struct speech_recognition_list_constraint, ISpeechRecognitionListConstraint_iface);
+}
+
+static inline struct speech_recognition_list_constraint
+        *impl_from_ISpeechRecognitionConstraint(ISpeechRecognitionConstraint *iface)
+{
+    return CONTAINING_RECORD(iface, struct speech_recognition_list_constraint, ISpeechRecognitionConstraint_iface);
+}
+
+/*
+*
+* ISpeechRecognitionListConstraint
+*
+*/
+
+#pragma region ISpeechRecognitionListConstraint
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_list_constraint_QueryInterface(ISpeechRecognitionListConstraint *iface, REFIID iid, void **out)
+{
+    struct speech_recognition_list_constraint *This = impl_from_ISpeechRecognitionListConstraint(iface);
+
+    TRACE("iface %p, iid %s, out %p stub!\n", iface, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IUnknown) ||
+        IsEqualGUID(iid, &IID_IInspectable) ||
+        IsEqualGUID(iid, &IID_ISpeechRecognitionListConstraint))
+    {
+        IUnknown_AddRef(iface);
+        *out = iface;
+        return S_OK;
+    }
+
+    if(IsEqualGUID(iid, &IID_ISpeechRecognitionConstraint))
+    {
+        IUnknown_AddRef(iface);
+        *out = &This->ISpeechRecognitionConstraint_iface;
+        return S_OK;
+    }
+
+    WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG STDMETHODCALLTYPE speech_recognition_list_constraint_AddRef(ISpeechRecognitionListConstraint *iface)
+{
+    struct speech_recognition_list_constraint *This = impl_from_ISpeechRecognitionListConstraint(iface);
+
+    ULONG ref = InterlockedIncrement(&This->ref);
+    TRACE("iface %p, ref %u.\n", iface, ref);
+
+    return ref;
+}
+
+static ULONG STDMETHODCALLTYPE speech_recognition_list_constraint_Release(ISpeechRecognitionListConstraint *iface)
+{
+    struct speech_recognition_list_constraint *This = impl_from_ISpeechRecognitionListConstraint(iface);
+
+    ULONG ref = InterlockedDecrement(&This->ref);
+    TRACE("iface %p, ref %u.\n", iface, ref);
+
+    if(!ref)
+        heap_free(This);
+
+    return ref;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_list_constraint_GetIids(ISpeechRecognitionListConstraint *iface, ULONG *iid_count, IID **iids)
+{
+    FIXME("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_list_constraint_GetRuntimeClassName(ISpeechRecognitionListConstraint *iface, HSTRING *class_name)
+{
+    FIXME("iface %p, class_name %p stub!\n", iface, class_name);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_list_constraint_GetTrustLevel(ISpeechRecognitionListConstraint *iface, TrustLevel *trust_level)
+{
+    FIXME("iface %p, trust_level %p stub!\n", iface, trust_level);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_list_constraint_get_Commands(ISpeechRecognitionListConstraint *iface, IVectorView_HSTRING **value)
+{
+    FIXME("iface %p, value %p stub!\n", iface, value);
+    return E_NOTIMPL;
+}
+
+static const struct ISpeechRecognitionListConstraintVtbl i_speech_recognition_list_constraint_vtbl =
+{
+    /* IUnknown methods */
+    speech_recognition_list_constraint_QueryInterface,
+    speech_recognition_list_constraint_AddRef,
+    speech_recognition_list_constraint_Release,
+    /* IInspectable methods */
+    speech_recognition_list_constraint_GetIids,
+    speech_recognition_list_constraint_GetRuntimeClassName,
+    speech_recognition_list_constraint_GetTrustLevel,
+    /* ISpeechRecognitionListConstraint methods */
+    speech_recognition_list_constraint_get_Commands
+};
+
+#pragma endregion ISpeechRecognitionListConstraint
+
+/*
+*
+* ISpeechRecognitionConstraint
+*
+*/
+
+#pragma region ISpeechRecognitionConstraint
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_constraint_QueryInterface(ISpeechRecognitionConstraint *iface, REFIID iid, void **out)
+{
+    struct speech_recognition_list_constraint *This = impl_from_ISpeechRecognitionConstraint(iface);
+
+    TRACE("iface %p, iid %s, out %p stub!\n", iface, debugstr_guid(iid), out);
+
+    /* IUnknown_QueryInterface already defined by ISpeechRecognitionListConstraint_iface. Redirect there. */
+    return ISpeechRecognitionListConstraint_QueryInterface(&This->ISpeechRecognitionListConstraint_iface, iid, out);
+}
+
+static ULONG STDMETHODCALLTYPE speech_recognition_constraint_AddRef(ISpeechRecognitionConstraint *iface)
+{
+    struct speech_recognition_list_constraint *This = impl_from_ISpeechRecognitionConstraint(iface);
+
+    TRACE("iface %p\n", iface);
+
+    /* IUnknown_AddRef already defined by ISpeechRecognitionListConstraint_iface. Redirect there. */
+    return ISpeechRecognitionListConstraint_AddRef(&This->ISpeechRecognitionListConstraint_iface);
+}
+
+static ULONG STDMETHODCALLTYPE speech_recognition_constraint_Release(ISpeechRecognitionConstraint *iface)
+{
+    struct speech_recognition_list_constraint *This = impl_from_ISpeechRecognitionConstraint(iface);
+
+    TRACE("iface %p\n", iface);
+
+    /* IUnknown_Release already defined by ISpeechRecognitionListConstraint_iface. Redirect there. */
+    return ISpeechRecognitionListConstraint_Release(&This->ISpeechRecognitionListConstraint_iface);
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_constraint_GetIids(ISpeechRecognitionConstraint *iface, ULONG *iid_count, IID **iids)
+{
+    struct speech_recognition_list_constraint *This = impl_from_ISpeechRecognitionConstraint(iface);
+
+    TRACE("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
+
+    /* IInspectable_GetIids already defined by ISpeechRecognitionListConstraint_iface. Redirect there. */
+    return ISpeechRecognitionListConstraint_GetIids(&This->ISpeechRecognitionListConstraint_iface, iid_count, iids);
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_constraint_GetRuntimeClassName(ISpeechRecognitionConstraint *iface, HSTRING *class_name)
+{
+    struct speech_recognition_list_constraint *This = impl_from_ISpeechRecognitionConstraint(iface);
+
+    TRACE("iface %p, class_name %p stub!\n", iface, class_name);
+
+    /* IInspectable_GetRuntimeClassName already defined by ISpeechRecognitionListConstraint_iface. Redirect there. */
+    return ISpeechRecognitionListConstraint_GetRuntimeClassName(&This->ISpeechRecognitionListConstraint_iface, class_name);
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_constraint_GetTrustLevel(ISpeechRecognitionConstraint *iface, TrustLevel *trust_level)
+{
+    struct speech_recognition_list_constraint *This = impl_from_ISpeechRecognitionConstraint(iface);
+
+    TRACE("iface %p, trust_level %p stub!\n", iface, trust_level);
+
+    /* IInspectable_GetTrustLevel already defined by ISpeechRecognitionListConstraint_iface. Redirect there. */
+    return ISpeechRecognitionListConstraint_GetTrustLevel(&This->ISpeechRecognitionListConstraint_iface, trust_level);
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_constraint_get_IsEnabled(ISpeechRecognitionConstraint *iface, boolean **value)
+{
+    FIXME("iface %p, value %p stub!\n", iface, value);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_constraint_put_IsEnabled(ISpeechRecognitionConstraint *iface, boolean *value)
+{
+    FIXME("iface %p, value %p stub!\n", iface, value);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_constraint_get_Probability(
+    ISpeechRecognitionConstraint *iface, SpeechRecognitionConstraintProbability **value)
+{
+    FIXME("iface %p, value %p stub!\n", iface, value);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_constraint_put_Probability(
+    ISpeechRecognitionConstraint *iface, SpeechRecognitionConstraintProbability *value)
+{
+    FIXME("iface %p, value %p stub!\n", iface, value);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_constraint_get_Tag(
+    ISpeechRecognitionConstraint *iface, HSTRING **value)
+{
+    FIXME("iface %p, value %p stub!\n", iface, value);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_constraint_put_Tag(
+    ISpeechRecognitionConstraint *iface, HSTRING *value)
+{
+    FIXME("iface %p, value %p stub!\n", iface, value);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_constraint_get_Type(
+    ISpeechRecognitionConstraint *iface, SpeechRecognitionConstraintType **value)
+{
+    FIXME("iface %p, value %p stub!\n", iface, value);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognition_constraint_put_Type(
+    ISpeechRecognitionConstraint *iface, SpeechRecognitionConstraintType *value)
+{
+    FIXME("iface %p, value %p stub!\n", iface, value);
+    return E_NOTIMPL;
+}
+
+static const struct ISpeechRecognitionConstraintVtbl i_speech_recognition_constraint_vtbl =
+{
+    /* IUnknown methods */
+    speech_recognition_constraint_QueryInterface,
+    speech_recognition_constraint_AddRef,
+    speech_recognition_constraint_Release,
+    /* IInspectable methods */
+    speech_recognition_constraint_GetIids,
+    speech_recognition_constraint_GetRuntimeClassName,
+    speech_recognition_constraint_GetTrustLevel,
+    /* ISpeechRecognitionConstraint methods */
+    speech_recognition_constraint_get_IsEnabled,
+    speech_recognition_constraint_put_IsEnabled,
+    speech_recognition_constraint_get_Probability,
+    speech_recognition_constraint_put_Probability,
+    speech_recognition_constraint_get_Tag,
+    speech_recognition_constraint_put_Tag,
+    speech_recognition_constraint_get_Type,
+    speech_recognition_constraint_put_Type,
+};
+
+#pragma endregion ISpeechRecognitionConstraint
+
+HRESULT speech_recognition_list_constraint_create(REFIID iid, void **obj)
+{
+    struct speech_recognition_list_constraint *This;
+    HRESULT hr;
+
+    if (!(This = heap_alloc_zero(sizeof(*This))))
+        return E_OUTOFMEMORY;
+
+    This->ISpeechRecognitionListConstraint_iface.lpVtbl = &i_speech_recognition_list_constraint_vtbl;
+    This->ISpeechRecognitionConstraint_iface.lpVtbl = &i_speech_recognition_constraint_vtbl;
+    This->ref = 1;
+
+    hr = ISpeechRecognitionListConstraint_QueryInterface(&This->ISpeechRecognitionListConstraint_iface, iid, obj);
+    ISpeechRecognitionListConstraint_Release(&This->ISpeechRecognitionListConstraint_iface);
+
+    return hr;
+}
+
+/*
+*
+* SpeechRecognizer
+*
+*/
+
+struct speech_recognizer
+{
+    ISpeechRecognizer ISpeechRecognizer_iface;
+    ISpeechRecognizer2 ISpeechRecognizer2_iface;
+    LONG ref;
+};
+
+static inline struct speech_recognizer *impl_from_ISpeechRecognizer(ISpeechRecognizer *iface)
+{
+    return CONTAINING_RECORD(iface, struct speech_recognizer, ISpeechRecognizer_iface);
+}
+
+static inline struct speech_recognizer *impl_from_ISpeechRecognizer2(ISpeechRecognizer2 *iface)
+{
+    return CONTAINING_RECORD(iface, struct speech_recognizer, ISpeechRecognizer2_iface);
+}
+
+/*
+*
+* ISpeechRecognizer
+*
+*/
+
+#pragma region ISpeechRecognizer
+
+static HRESULT STDMETHODCALLTYPE speech_recognizer_QueryInterface(ISpeechRecognizer *iface, REFIID iid, void **out)
+{
+    struct speech_recognizer *This = impl_from_ISpeechRecognizer(iface);
+
+    TRACE("iface %p, iid %s, out %p stub!\n", iface, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IUnknown) ||
+        IsEqualGUID(iid, &IID_IInspectable) ||
+        IsEqualGUID(iid, &IID_ISpeechRecognizer))
+    {
+        IUnknown_AddRef(iface);
+        *out = iface;
+        return S_OK;
+    }
+
+    if(IsEqualGUID(iid, &IID_ISpeechRecognizer2))
+    {
+        IUnknown_AddRef(iface);
+        *out = &This->ISpeechRecognizer2_iface;
+        return S_OK;
+    }
+
+    WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG STDMETHODCALLTYPE speech_recognizer_AddRef(ISpeechRecognizer *iface)
+{
+    struct speech_recognizer *This = impl_from_ISpeechRecognizer(iface);
+
+    ULONG ref = InterlockedIncrement(&This->ref);
+    TRACE("iface %p, ref %u.\n", iface, ref);
+
+    return ref;
+}
+
+static ULONG STDMETHODCALLTYPE speech_recognizer_Release(ISpeechRecognizer *iface)
+{
+    struct speech_recognizer *This = impl_from_ISpeechRecognizer(iface);
+
+    ULONG ref = InterlockedDecrement(&This->ref);
+    TRACE("iface %p, ref %u.\n", iface, ref);
+
+    if(!ref)
+        heap_free(This);
+
+    return ref;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognizer_GetIids(ISpeechRecognizer *iface, ULONG *iid_count, IID **iids)
+{
+    FIXME("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognizer_GetRuntimeClassName(ISpeechRecognizer *iface, HSTRING *class_name)
+{
+    FIXME("iface %p, class_name %p stub!\n", iface, class_name);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognizer_GetTrustLevel(ISpeechRecognizer *iface, TrustLevel *trust_level)
+{
+    FIXME("iface %p, trust_level %p stub!\n", iface, trust_level);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognizer_CompileConstraintsAsync(ISpeechRecognizer *iface,
+    IAsyncOperation_SpeechRecognitionCompilationResult **operation)
+{
+    FIXME("iface %p, operation %p stub!\n", iface, operation);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognizer_RecognizeAsync(ISpeechRecognizer *iface,
+    IAsyncOperation_SpeechRecognitionResult **operation)
+{
+    FIXME("iface %p, operation %p stub!\n", iface, operation);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognizer_RecognizeWithUIAsync(ISpeechRecognizer *iface,
+    IAsyncOperation_SpeechRecognitionResult **operation)
+{
+    FIXME("iface %p, operation %p stub!\n", iface, operation);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognizer_get_Constraints(ISpeechRecognizer *iface,
+    IVectorView_ISpeechRecognitionConstraint **vector)
+{
+    FIXME("iface %p, operation %p stub!\n", iface, vector);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognizer_get_CurrentLanguage(ISpeechRecognizer *iface,
+    ILanguage **language)
+{
+    FIXME("iface %p, operation %p stub!\n", iface, language);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognizer_get_Timeouts(ISpeechRecognizer *iface,
+    ISpeechRecognizerTimeouts **timeouts)
+{
+    FIXME("iface %p, operation %p stub!\n", iface, timeouts);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognizer_get_UIOptions(ISpeechRecognizer *iface,
+    ISpeechRecognizerUIOptions **options)
+{
+    FIXME("iface %p, operation %p stub!\n", iface, options);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognizer_add_RecognitionQualityDegrading(ISpeechRecognizer *iface,
+    ITypedEventHandler_ISpeechRecognizer_ISpeechRecognitionQualityDegradingEventArgs *handler, EventRegistrationToken *token)
+{
+    FIXME("iface %p, operation %p, token %p, stub!\n", iface, handler, token);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognizer_remove_RecognitionQualityDegrading(
+    ISpeechRecognizer *iface, EventRegistrationToken token)
+{
+    FIXME("iface %p, token %#I64x, stub!\n", iface, token);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognizer_add_StateChanged(ISpeechRecognizer *iface,
+    ITypedEventHandler_ISpeechRecognizer_ISpeechRecognizerStateChangedEventArgs *handler, EventRegistrationToken *token)
+{
+    FIXME("iface %p, operation %p, token %p, stub!\n", iface, handler, token);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognizer_remove_StateChanged(
+    ISpeechRecognizer *iface, EventRegistrationToken token)
+{
+    FIXME("iface %p, token %#I64x, stub!\n", iface, token);
+    return E_NOTIMPL;
+}
+
+static const struct ISpeechRecognizerVtbl i_speech_recognizer_vtbl =
+{
+    /* IUnknown methods */
+    speech_recognizer_QueryInterface,
+    speech_recognizer_AddRef,
+    speech_recognizer_Release,
+    /* IInspectable methods */
+    speech_recognizer_GetIids,
+    speech_recognizer_GetRuntimeClassName,
+    speech_recognizer_GetTrustLevel,
+    /* ISpeechRecognizer methods */
+    speech_recognizer_CompileConstraintsAsync,
+    speech_recognizer_RecognizeAsync,
+    speech_recognizer_RecognizeWithUIAsync,
+    speech_recognizer_get_Constraints,
+    speech_recognizer_get_CurrentLanguage,
+    speech_recognizer_get_Timeouts,
+    speech_recognizer_get_UIOptions,
+    speech_recognizer_add_RecognitionQualityDegrading,
+    speech_recognizer_remove_RecognitionQualityDegrading,
+    speech_recognizer_add_StateChanged,
+    speech_recognizer_remove_StateChanged,
+};
+
+#pragma endregion ISpeechRecognizer
+
+/*
+*
+* ISpeechRecognizer2
+*
+*/
+
+#pragma region ISpeechRecognizer2
+
+static HRESULT STDMETHODCALLTYPE speech_recognizer2_QueryInterface(ISpeechRecognizer2 *iface, REFIID iid, void **out)
+{
+    struct speech_recognizer *This = impl_from_ISpeechRecognizer2(iface);
+
+    TRACE("iface %p, iid %s, out %p stub!\n", iface, debugstr_guid(iid), out);
+
+    /* IUnknown_QueryInterface already defined by ISpeechRecognizer_iface. Redirect there. */
+    return ISpeechRecognizer_QueryInterface(&This->ISpeechRecognizer_iface, iid, out);
+}
+
+static ULONG STDMETHODCALLTYPE speech_recognizer2_AddRef(ISpeechRecognizer2 *iface)
+{
+    struct speech_recognizer *This = impl_from_ISpeechRecognizer2(iface);
+
+    TRACE("iface %p\n", iface);
+
+    /* IUnknown_AddRef already defined by ISpeechRecognizer_iface. Redirect there. */
+    return ISpeechRecognizer_AddRef(&This->ISpeechRecognizer_iface);
+}
+
+static ULONG STDMETHODCALLTYPE speech_recognizer2_Release(ISpeechRecognizer2 *iface)
+{
+    struct speech_recognizer *This = impl_from_ISpeechRecognizer2(iface);
+
+    TRACE("iface %p\n", iface);
+
+    /* IUnknown_Release already defined by ISpeechRecognizer_iface. Redirect there. */
+    return ISpeechRecognizer_Release(&This->ISpeechRecognizer_iface);
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognizer2_GetIids(ISpeechRecognizer2 *iface, ULONG *iid_count, IID **iids)
+{
+    struct speech_recognizer *This = impl_from_ISpeechRecognizer2(iface);
+
+    TRACE("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
+
+    /* IInspectable_GetIids already defined by ISpeechRecognizer_iface. Redirect there. */
+    return ISpeechRecognizer_GetIids(&This->ISpeechRecognizer_iface, iid_count, iids);
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognizer2_GetRuntimeClassName(ISpeechRecognizer2 *iface, HSTRING *class_name)
+{
+    struct speech_recognizer *This = impl_from_ISpeechRecognizer2(iface);
+
+    TRACE("iface %p, class_name %p stub!\n", iface, class_name);
+
+    /* IInspectable_GetRuntimeClassName already defined by ISpeechRecognizer_iface. Redirect there. */
+    return ISpeechRecognizer_GetRuntimeClassName(&This->ISpeechRecognizer_iface, class_name);
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognizer2_GetTrustLevel(ISpeechRecognizer2 *iface, TrustLevel *trust_level)
+{
+    struct speech_recognizer *This = impl_from_ISpeechRecognizer2(iface);
+
+    TRACE("iface %p, trust_level %p stub!\n", iface, trust_level);
+
+    /* IInspectable_GetTrustLevel already defined by ISpeechRecognizer_iface. Redirect there. */
+    return ISpeechRecognizer_GetTrustLevel(&This->ISpeechRecognizer_iface, trust_level);
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognizer2_StopRecognitionAsync(ISpeechRecognizer2 *iface,
+    IAsyncAction **action)
+{
+    FIXME("iface %p, action %p stub!\n", iface, action);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognizer2_get_ContinuousRecognitionSession(ISpeechRecognizer2 *iface,
+    ISpeechContinuousRecognitionSession **session)
+{
+    FIXME("iface %p, session %p stub!\n", iface, session);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognizer2_get_State(ISpeechRecognizer2 *iface,
+    SpeechRecognizerState *state)
+{
+    FIXME("iface %p, state %p stub!\n", iface, state);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognizer2_add_HypothesisGenerated(ISpeechRecognizer2 *iface,
+    ITypedEventHandler_ISpeechRecognizer2_ISpeechRecognitionHypothesisGeneratedEventArgs *handler, EventRegistrationToken *token)
+{
+    FIXME("iface %p, operation %p, token %p, stub!\n", iface, handler, token);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_recognizer2_remove_HypothesisGenerated(
+    ISpeechRecognizer2 *iface, EventRegistrationToken token)
+{
+    FIXME("iface %p, token %#I64x, stub!\n", iface, token);
+    return E_NOTIMPL;
+}
+
+static const struct ISpeechRecognizer2Vtbl i_speech_recognizer2_vtbl =
+{
+    /* IUnknown methods */
+    speech_recognizer2_QueryInterface,
+    speech_recognizer2_AddRef,
+    speech_recognizer2_Release,
+    /* IInspectable methods */
+    speech_recognizer2_GetIids,
+    speech_recognizer2_GetRuntimeClassName,
+    speech_recognizer2_GetTrustLevel,
+    /* ISpeechRecognizer2 methods */
+    speech_recognizer2_StopRecognitionAsync,
+    speech_recognizer2_get_ContinuousRecognitionSession,
+    speech_recognizer2_get_State,
+    speech_recognizer2_add_HypothesisGenerated,
+    speech_recognizer2_remove_HypothesisGenerated,
+};
+
+#pragma endregion ISpeechRecognizer2
+
+HRESULT speech_recognizer_create(REFIID iid, void **obj)
+{
+    struct speech_recognizer *This;
+    HRESULT hr;
+
+    if (!(This = heap_alloc_zero(sizeof(*This))))
+        return E_OUTOFMEMORY;
+
+    This->ISpeechRecognizer_iface.lpVtbl = &i_speech_recognizer_vtbl;
+    This->ISpeechRecognizer2_iface.lpVtbl = &i_speech_recognizer2_vtbl;
+    This->ref = 1;
+
+    hr = ISpeechRecognizer_QueryInterface(&This->ISpeechRecognizer_iface, iid, obj);
+    ISpeechRecognizer_Release(&This->ISpeechRecognizer_iface);
+
+    return hr;
+}
+
+
diff --git a/dlls/windows.media.speech/speechsynthesis.c b/dlls/windows.media.speech/speechsynthesis.c
new file mode 100644
index 00000000000..d0185d80748
--- /dev/null
+++ b/dlls/windows.media.speech/speechsynthesis.c
@@ -0,0 +1,497 @@
+/* WinRT Windows.Media.Speech implementation
+ *
+ * Copyright 2021 Rémi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "windows_media_speech_private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(speech);
+
+struct windows_media_speech
+{
+    IActivationFactory IActivationFactory_iface;
+    IInstalledVoicesStatic IInstalledVoicesStatic_iface;
+
+    LONG ref;
+};
+
+/*
+*
+* IVectorView_VoiceInformation
+*
+*/
+
+struct voice_information_vector
+{
+    IVectorView_VoiceInformation IVectorView_VoiceInformation_iface;
+    LONG ref;
+};
+
+static inline struct voice_information_vector *impl_from_IVectorView_VoiceInformation(IVectorView_VoiceInformation *iface)
+{
+    return CONTAINING_RECORD(iface, struct voice_information_vector, IVectorView_VoiceInformation_iface);
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_voice_information_QueryInterface(
+        IVectorView_VoiceInformation *iface, REFIID iid, void **out)
+{
+    TRACE("iface %p, iid %s, out %p stub!\n", iface, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IUnknown) ||
+        IsEqualGUID(iid, &IID_IInspectable) ||
+        IsEqualGUID(iid, &IID_IVectorView_VoiceInformation))
+    {
+        IUnknown_AddRef(iface);
+        *out = iface;
+        return S_OK;
+    }
+
+    WARN("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG STDMETHODCALLTYPE vector_view_voice_information_AddRef(
+        IVectorView_VoiceInformation *iface)
+{
+    struct voice_information_vector *impl = impl_from_IVectorView_VoiceInformation(iface);
+    ULONG ref = InterlockedIncrement(&impl->ref);
+    TRACE("iface %p, ref %u.\n", iface, ref);
+    return ref;
+}
+
+static ULONG STDMETHODCALLTYPE vector_view_voice_information_Release(
+        IVectorView_VoiceInformation *iface)
+{
+    struct voice_information_vector *impl = impl_from_IVectorView_VoiceInformation(iface);
+    ULONG ref = InterlockedDecrement(&impl->ref);
+    TRACE("iface %p, ref %u.\n", iface, ref);
+    return ref;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_voice_information_GetIids(
+        IVectorView_VoiceInformation *iface, ULONG *iid_count, IID **iids)
+{
+    FIXME("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_voice_information_GetRuntimeClassName(
+        IVectorView_VoiceInformation *iface, HSTRING *class_name)
+{
+    FIXME("iface %p, class_name %p stub!\n", iface, class_name);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_voice_information_GetTrustLevel(
+        IVectorView_VoiceInformation *iface, TrustLevel *trust_level)
+{
+    FIXME("iface %p, trust_level %p stub!\n", iface, trust_level);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_voice_information_GetAt(
+        IVectorView_VoiceInformation *iface, UINT32 index, IVoiceInformation **value)
+{
+    FIXME("iface %p, index %#x, value %p stub!\n", iface, index, value);
+    *value = NULL;
+    return E_BOUNDS;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_voice_information_get_Size(
+        IVectorView_VoiceInformation *iface, UINT32 *value)
+{
+    FIXME("iface %p, value %p stub!\n", iface, value);
+    *value = 0;
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_voice_information_IndexOf(
+        IVectorView_VoiceInformation *iface, IVoiceInformation *element, UINT32 *index, BOOLEAN *found)
+{
+    FIXME("iface %p, element %p, index %p, found %p stub!\n", iface, element, index, found);
+    *index = 0;
+    *found = FALSE;
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE vector_view_voice_information_GetMany(
+        IVectorView_VoiceInformation *iface, UINT32 start_index,
+        UINT32 items_size, IVoiceInformation **items, UINT *value)
+{
+    FIXME("iface %p, start_index %#x, items %p, value %p stub!\n", iface, start_index, items, value);
+    *value = 0;
+    return S_OK;
+}
+
+static const struct IVectorView_VoiceInformationVtbl vector_view_voice_information_vtbl =
+{
+    vector_view_voice_information_QueryInterface,
+    vector_view_voice_information_AddRef,
+    vector_view_voice_information_Release,
+    /* IInspectable methods */
+    vector_view_voice_information_GetIids,
+    vector_view_voice_information_GetRuntimeClassName,
+    vector_view_voice_information_GetTrustLevel,
+    /* IVectorView<VoiceInformation> methods */
+    vector_view_voice_information_GetAt,
+    vector_view_voice_information_get_Size,
+    vector_view_voice_information_IndexOf,
+    vector_view_voice_information_GetMany,
+};
+
+static struct voice_information_vector all_voices =
+{
+    {&vector_view_voice_information_vtbl},
+    0
+};
+
+/*
+*
+* IInstalledVoicesStatic
+*
+*/
+
+static inline struct windows_media_speech *impl_from_IInstalledVoicesStatic(IInstalledVoicesStatic *iface)
+{
+    return CONTAINING_RECORD(iface, struct windows_media_speech, IInstalledVoicesStatic_iface);
+}
+
+static HRESULT STDMETHODCALLTYPE installed_voices_static_QueryInterface(
+        IInstalledVoicesStatic *iface, REFIID iid, void **out)
+{
+    // struct windows_media_speech *impl = impl_from_IInstalledVoicesStatic(iface);
+    // return windows_media_speech_QueryInterface(&impl->IActivationFactory_iface, iid, out);
+    return E_NOTIMPL;
+}
+
+static ULONG STDMETHODCALLTYPE installed_voices_static_AddRef(
+        IInstalledVoicesStatic *iface)
+{
+    //struct windows_media_speech *impl = impl_from_IInstalledVoicesStatic(iface);
+    //return windows_media_speech_AddRef(&impl->IActivationFactory_iface);
+    return E_NOTIMPL;
+}
+
+static ULONG STDMETHODCALLTYPE installed_voices_static_Release(
+        IInstalledVoicesStatic *iface)
+{
+    //struct windows_media_speech *impl = impl_from_IInstalledVoicesStatic(iface);
+    //return windows_media_speech_Release(&impl->IActivationFactory_iface);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE installed_voices_static_GetIids(
+        IInstalledVoicesStatic *iface, ULONG *iid_count, IID **iids)
+{
+    FIXME("iface %p, iid_count %p, iids %p stub!\n", iface, iid_count, iids);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE installed_voices_static_GetRuntimeClassName(
+        IInstalledVoicesStatic *iface, HSTRING *class_name)
+{
+    FIXME("iface %p, class_name %p stub!\n", iface, class_name);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE installed_voices_static_GetTrustLevel(
+        IInstalledVoicesStatic *iface, TrustLevel *trust_level)
+{
+    FIXME("iface %p, trust_level %p stub!\n", iface, trust_level);
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE installed_voices_static_get_AllVoices(
+    IInstalledVoicesStatic *iface, IVectorView_VoiceInformation **value)
+{
+    TRACE("iface %p, value %p.\n", iface, value);
+    *value = &all_voices.IVectorView_VoiceInformation_iface;
+    IVectorView_VoiceInformation_AddRef(*value);
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE installed_voices_static_get_DefaultVoice(
+    IInstalledVoicesStatic *iface, IVoiceInformation **value)
+{
+    FIXME("iface %p, value %p stub!\n", iface, value);
+    return E_NOTIMPL;
+}
+
+static const struct IInstalledVoicesStaticVtbl installed_voices_static_vtbl =
+{
+    installed_voices_static_QueryInterface,
+    installed_voices_static_AddRef,
+    installed_voices_static_Release,
+    /* IInspectable methods */
+    installed_voices_static_GetIids,
+    installed_voices_static_GetRuntimeClassName,
+    installed_voices_static_GetTrustLevel,
+    /* IInstalledVoicesStatic methods */
+    installed_voices_static_get_AllVoices,
+    installed_voices_static_get_DefaultVoice,
+};
+
+
+/*
+*
+* ISpeechSynthesizer
+*
+*/
+
+struct speech_synthesizer
+{
+    ISpeechSynthesizer ISpeechSynthesizer_iface;
+    IClosable IClosable_iface;
+    LONG ref;
+};
+
+static inline struct speech_synthesizer *impl_from_ISpeechSynthesizer(ISpeechSynthesizer *iface)
+{
+    return CONTAINING_RECORD(iface, struct speech_synthesizer, ISpeechSynthesizer_iface);
+}
+
+static inline struct speech_synthesizer *impl_from_IClosable(IClosable *iface)
+{
+    return CONTAINING_RECORD(iface, struct speech_synthesizer, IClosable_iface);
+}
+
+static HRESULT STDMETHODCALLTYPE speech_synthesizer_QueryInterface(
+        ISpeechSynthesizer *iface, REFIID iid, void **out)
+{
+    struct speech_synthesizer *impl = impl_from_ISpeechSynthesizer(iface);
+
+    TRACE("iface %p, iid %s, out %p stub!\n", iface, debugstr_guid(iid), out);
+
+    if (IsEqualGUID(iid, &IID_IUnknown) ||
+        IsEqualGUID(iid, &IID_IInspectable) ||
+        IsEqualGUID(iid, &IID_ISpeechSynthesizer))
+    {
+        IUnknown_AddRef(iface);
+        *out = iface;
+        return S_OK;
+    }
+
+    if (IsEqualGUID(iid, &IID_IClosable))
+    {
+        IUnknown_AddRef(iface);
+        *out = &impl->IClosable_iface;
+        return S_OK;
+    }
+
+    FIXME("%s not implemented, returning E_NOINTERFACE.\n", debugstr_guid(iid));
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG STDMETHODCALLTYPE speech_synthesizer_AddRef(
+        ISpeechSynthesizer *iface)
+{
+    struct speech_synthesizer *impl = impl_from_ISpeechSynthesizer(iface);
+    ULONG ref = InterlockedIncrement(&impl->ref);
+
+    TRACE("iface %p, ref %u.\n", iface, ref);
+
+    return ref;
+}
+
+static ULONG STDMETHODCALLTYPE speech_synthesizer_Release(
+        ISpeechSynthesizer *iface)
+{
+    struct speech_synthesizer *impl = impl_from_ISpeechSynthesizer(iface);
+    ULONG ref = InterlockedDecrement(&impl->ref);
+
+    TRACE("iface %p, ref %u.\n", iface, ref);
+
+    if (!ref)
+        free(impl);
+
+    return ref;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_synthesizer_GetIids(
+        ISpeechSynthesizer *iface, ULONG *iid_count, IID **iids)
+{
+    FIXME("iface %p, iid_count %p, iids %p stub.\n", iface, iid_count, iids);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_synthesizer_GetRuntimeClassName(
+        ISpeechSynthesizer *iface, HSTRING *class_name)
+{
+    FIXME("iface %p, class_name %p stub.\n", iface, class_name);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_synthesizer_GetTrustLevel(
+        ISpeechSynthesizer *iface, TrustLevel *trust_level)
+{
+    FIXME("iface %p, trust_level %p stub.\n", iface, trust_level);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_synthesizer_SynthesizeTextToStreamAsync(ISpeechSynthesizer *iface,
+        HSTRING text, IAsyncOperation_SpeechSynthesisStream **operation)
+{
+    FIXME("iface %p, text %p, operation %p stub.\n", iface, text, operation);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_synthesizer_SynthesizeSsmlToStreamAsync(ISpeechSynthesizer *iface,
+        HSTRING ssml, IAsyncOperation_SpeechSynthesisStream **operation)
+{
+    FIXME("iface %p, text %p, operation %p stub.\n", iface, ssml, operation);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_synthesizer_put_Voice(ISpeechSynthesizer *iface, IVoiceInformation *value)
+{
+    FIXME("iface %p, value %p stub.\n", iface, value);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE speech_synthesizer_get_Voice(ISpeechSynthesizer *iface, IVoiceInformation **value)
+{
+    FIXME("iface %p, value %p stub.\n", iface, value);
+
+    return E_NOTIMPL;
+}
+
+static const struct ISpeechSynthesizerVtbl speech_synthesizer_vtbl =
+{
+    /* IUnknown methods */
+    speech_synthesizer_QueryInterface,
+    speech_synthesizer_AddRef,
+    speech_synthesizer_Release,
+    /* IInspectable methods */
+    speech_synthesizer_GetIids,
+    speech_synthesizer_GetRuntimeClassName,
+    speech_synthesizer_GetTrustLevel,
+    /* ISpeechSynthesizer methods */
+    speech_synthesizer_SynthesizeTextToStreamAsync,
+    speech_synthesizer_SynthesizeSsmlToStreamAsync,
+    speech_synthesizer_put_Voice,
+    speech_synthesizer_get_Voice,
+};
+
+static HRESULT STDMETHODCALLTYPE speech_synthesizer_create(void)
+{
+    //     struct speech_synthesizer *obj;
+
+    // TRACE("iface %p, instance %p.\n", iface, instance);
+
+    // if (!(obj = calloc(1, sizeof(*obj))))
+    // {
+    //     *instance = NULL;
+    //     return E_OUTOFMEMORY;
+    // }
+
+    // obj->ISpeechSynthesizer_iface.lpVtbl = &speech_synthesizer_vtbl;
+    // obj->IClosable_iface.lpVtbl = &closable_vtbl;
+    // obj->ref = 1;
+    // *instance = (IInspectable *)&obj->ISpeechSynthesizer_iface;
+    // return S_OK;
+
+    return S_OK;
+}
+
+
+
+static HRESULT STDMETHODCALLTYPE closable_QueryInterface(
+        IClosable *iface, REFIID iid, void **out)
+{
+    struct speech_synthesizer *impl = impl_from_IClosable(iface);
+
+    return speech_synthesizer_QueryInterface(&impl->ISpeechSynthesizer_iface, iid, out);
+}
+
+static ULONG STDMETHODCALLTYPE closable_AddRef(
+        IClosable *iface)
+{
+    struct speech_synthesizer *impl = impl_from_IClosable(iface);
+    ULONG ref = InterlockedIncrement(&impl->ref);
+
+    TRACE("iface %p, ref %u.\n", iface, ref);
+
+    return ref;
+}
+
+static ULONG STDMETHODCALLTYPE closable_Release(
+        IClosable *iface)
+{
+    struct speech_synthesizer *impl = impl_from_IClosable(iface);
+    ULONG ref = InterlockedDecrement(&impl->ref);
+
+    TRACE("iface %p, ref %u.\n", iface, ref);
+
+    if (!ref)
+        free(impl);
+
+    return ref;
+}
+
+static HRESULT STDMETHODCALLTYPE closable_GetIids(
+        IClosable *iface, ULONG *iid_count, IID **iids)
+{
+    FIXME("iface %p, iid_count %p, iids %p stub.\n", iface, iid_count, iids);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE closable_GetRuntimeClassName(
+        IClosable *iface, HSTRING *class_name)
+{
+    FIXME("iface %p, class_name %p stub.\n", iface, class_name);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE closable_GetTrustLevel(
+        IClosable *iface, TrustLevel *trust_level)
+{
+    FIXME("iface %p, trust_level %p stub.\n", iface, trust_level);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT STDMETHODCALLTYPE closable_Close(
+        IClosable *iface)
+{
+    FIXME("iface %p stub.\n", iface);
+
+    return E_NOTIMPL;
+}
+
+static const struct IClosableVtbl closable_vtbl =
+{
+    /* IUnknown methods */
+    closable_QueryInterface,
+    closable_AddRef,
+    closable_Release,
+    /* IInspectable methods */
+    closable_GetIids,
+    closable_GetRuntimeClassName,
+    closable_GetTrustLevel,
+    /* IClosable methods */
+    closable_Close,
+};
diff --git a/dlls/windows.media.speech/windows_media_speech_private.h b/dlls/windows.media.speech/windows_media_speech_private.h
new file mode 100644
index 00000000000..7089c2438aa
--- /dev/null
+++ b/dlls/windows.media.speech/windows_media_speech_private.h
@@ -0,0 +1,86 @@
+/* WinRT Windows.Media.Speech private header
+ *
+ * Copyright 2021 Bernhard Kölbl
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WINDOWS_MEDIA_SPEECH_PRIVATE_H
+#define __WINE_WINDOWS_MEDIA_SPEECH_PRIVATE_H
+
+#include "wine/debug.h"
+#include "wine/heap.h"
+
+#include <stdarg.h>
+
+#define COBJMACROS
+#include "windef.h"
+#include "winbase.h"
+#include "winstring.h"
+#include "objbase.h"
+
+#ifdef WINDOWS_MEDIA_SPEECH_INIT_GUID
+#include "initguid.h"
+#endif
+
+#include "activation.h"
+
+#define WIDL_using_Windows_Foundation
+#define WIDL_using_Windows_Foundation_Collections
+#include "windows.foundation.h"
+#define WIDL_using_Windows_Globalization
+#include "windows.globalization.h"
+#define WIDL_using_Windows_Media_SpeechSynthesis
+#include "windows.media.speechsynthesis.h"
+#define WIDL_using_Windows_Media_SpeechRecognition
+#include "windows.media.speechrecognition.h"
+
+
+
+// static HRESULT speech_continuous_recognition_completed_event_args_create(REFIID iid, void **obj);
+// static HRESULT speech_recognizer_create(REFIID iid, void **obj);
+
+#define IsEqualClassID(classid1, classid2) (!wcscmp(classid1, classid2))
+
+static inline const char *debugstr_hstring(HSTRING hstr)
+{
+    const WCHAR *str;
+    UINT32 len;
+    if (hstr && !((ULONG_PTR)hstr >> 16)) return "(invalid)";
+    str = WindowsGetStringRawBuffer(hstr, &len);
+    return wine_dbgstr_wn(str, len);
+}
+
+
+/*
+ *
+ * SpeechRecognition
+ * 
+ */
+
+HRESULT speech_continuous_recognition_completed_event_args_create(REFIID iid, void **obj) DECLSPEC_HIDDEN;
+HRESULT speech_recognition_list_constraint_create(REFIID iid, void **obj) DECLSPEC_HIDDEN;
+HRESULT speech_recognizer_create(REFIID iid, void **obj) DECLSPEC_HIDDEN;
+
+
+/*
+ *
+ * SpeechSynthesis
+ * 
+ */
+
+
+
+#endif
diff --git a/include/Makefile.in b/include/Makefile.in
index e5ae8429ed0..cdbd5025348 100644
--- a/include/Makefile.in
+++ b/include/Makefile.in
@@ -781,6 +781,7 @@ SOURCES = \
 	windows.h \
 	windows.media.devices.idl \
 	windows.media.idl \
+	windows.media.speechrecognition.idl \
 	windows.media.speechsynthesis.idl \
 	windows.storage.streams.idl \
 	windows.system.idl \
diff --git a/include/windows.foundation.idl b/include/windows.foundation.idl
index 292522f2c49..86cd8eb6a5d 100644
--- a/include/windows.foundation.idl
+++ b/include/windows.foundation.idl
@@ -128,6 +128,15 @@ namespace Windows {
         {
             HRESULT Close();
         }
+
+        [
+            contract(Windows.Foundation.FoundationContract, 1.0),
+            uuid(30d5a829-7fa4-4026-83bb-d75bae4ea99e)
+        ]
+        interface IAsyncAction : IInspectable
+        {
+            
+        }
     }
 }
 
diff --git a/include/windows.globalization.idl b/include/windows.globalization.idl
index c08f7bd27d9..405c24ae728 100644
--- a/include/windows.globalization.idl
+++ b/include/windows.globalization.idl
@@ -29,6 +29,10 @@ import "windows.foundation.idl";
 namespace Windows {
     namespace Globalization {
         typedef enum DayOfWeek DayOfWeek;
+        interface ILanguage;
+        interface ILanguage2;
+        interface ILanguage3;
+        runtimeclass Language;
     }
 }
 
@@ -45,5 +49,43 @@ namespace Windows {
             Friday    = 5,
             Saturday  = 6
         };
+
+        [
+            exclusiveto(Windows.Globalization.Language),
+            uuid(EA79A752-F7C2-4265-B1BD-C4DEC4E4F080)
+        ]
+        interface ILanguage : IInspectable
+        {
+
+        }
+
+        [
+            exclusiveto(Windows.Globalization.Language),
+            uuid(6A47E5B5-D94D-4886-A404-A5A5B9D5B494)
+        ]
+        interface ILanguage2 : IInspectable
+        {
+
+        }
+
+        [
+            exclusiveto(Windows.Globalization.Language),
+            uuid(C6AF3D10-641A-5BA4-BB43-5E12AED75954)
+        ]
+        interface ILanguage3 : IInspectable
+        {
+
+        }
+
+        [
+            marshaling_behavior(agile),
+            uuid(144B0F3D-2D59-5DD2-B012-908EC3E06435)
+        ]
+        runtimeclass Language
+        {
+            [default] interface Windows.Globalization.ILanguage;
+            interface Windows.Globalization.ILanguage2;
+            interface Windows.Globalization.ILanguage3;
+        }
     }
 }
diff --git a/include/windows.media.speechrecognition.idl b/include/windows.media.speechrecognition.idl
new file mode 100644
index 00000000000..3519c022493
--- /dev/null
+++ b/include/windows.media.speechrecognition.idl
@@ -0,0 +1,445 @@
+/*
+ * Copyright 2021 Bernhard Kölbl
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifdef __WIDL__
+#pragma winrt ns_prefix
+#endif
+
+import "inspectable.idl";
+import "windows.globalization.idl";
+import "windows.foundation.idl";
+import "windows.media.idl";
+
+namespace Windows {
+    namespace Media {
+        namespace SpeechRecognition {
+            typedef enum SpeechContinuousRecognitionMode SpeechContinuousRecognitionMode;
+            typedef enum SpeechRecognitionAudioProblem SpeechRecognitionAudioProblem;
+            typedef enum SpeechRecognitionConfidence SpeechRecognitionConfidence;
+            typedef enum SpeechRecognitionConstraintProbability SpeechRecognitionConstraintProbability;
+            typedef enum SpeechRecognitionConstraintType SpeechRecognitionConstraintType;
+            typedef enum SpeechRecognitionResultStatus SpeechRecognitionResultStatus;
+            typedef enum SpeechRecognitionScenario SpeechRecognitionScenario;
+            typedef enum SpeechRecognizerState SpeechRecognizerState; 
+            interface ISpeechContinuousRecognitionCompletedEventArgs;
+            // interface ISpeechContinuousRecognitionResultGeneratedEventArgs;
+            interface ISpeechContinuousRecognitionSession;
+            interface ISpeechRecognitionCompilationResult;
+            interface ISpeechRecognitionConstraint;
+            // interface ISpeechRecognitionGrammarFileConstraint;
+            // interface ISpeechRecognitionGrammarFileConstraintFactory;
+            // interface ISpeechRecognitionHypothesis;
+            interface ISpeechRecognitionHypothesisGeneratedEventArgs;
+            interface ISpeechRecognitionListConstraint;
+            interface ISpeechRecognitionListConstraintFactory;
+            interface ISpeechRecognitionQualityDegradingEventArgs;
+            interface ISpeechRecognitionResult;
+            interface ISpeechRecognitionResult2;
+            // interface ISpeechRecognitionSemanticInterpretation;
+            // interface ISpeechRecognitionTopicConstraint;
+            // interface ISpeechRecognitionTopicConstraintFactory;
+            // interface ISpeechRecognitionVoiceCommandDefinitionConstraint;
+            interface ISpeechRecognizer;
+            interface ISpeechRecognizer2;
+            interface ISpeechRecognizerFactory;
+            interface ISpeechRecognizerStateChangedEventArgs;
+            // interface ISpeechRecognizerStatics;
+            // interface ISpeechRecognizerStatics2;
+            interface ISpeechRecognizerTimeouts;
+            interface ISpeechRecognizerUIOptions;
+            runtimeclass SpeechRecognizerUIOptions;
+            runtimeclass SpeechContinuousRecognitionCompletedEventArgs;
+            // runtimeclass SpeechContinuousRecognitionResultGeneratedEventArgs;
+            runtimeclass SpeechRecognitionCompilationResult;
+            // runtimeclass SpeechRecognitionGrammarFileConstraint;
+            // runtimeclass SpeechRecognitionHypothesis;
+            // runtimeclass SpeechRecognitionHypothesisGeneratedEventArgs;
+            runtimeclass SpeechRecognitionListConstraint;
+            runtimeclass SpeechRecognitionQualityDegradingEventArgs;
+            runtimeclass SpeechRecognitionResult;
+            // runtimeclass SpeechRecognitionSemanticInterpretation;
+            // runtimeclass SpeechRecognitionTopicConstraint;
+            // runtimeclass SpeechRecognitionVoiceCommandDefinitionConstraint;
+            runtimeclass SpeechRecognizer;
+            runtimeclass SpeechRecognizerStateChangedEventArgs;
+            runtimeclass SpeechRecognizerTimeouts;
+        }
+    }
+}
+
+namespace Windows {
+    namespace Media {
+        namespace SpeechRecognition {
+            declare {
+                interface Windows.Foundation.IAsyncOperation<Windows.Media.SpeechRecognition.SpeechRecognitionCompilationResult*>;
+                interface Windows.Foundation.AsyncOperationCompletedHandler<Windows.Media.SpeechRecognition.SpeechRecognitionCompilationResult*>;
+                interface Windows.Foundation.IAsyncOperation<Windows.Media.SpeechRecognition.SpeechRecognitionResult*>;
+                interface Windows.Foundation.AsyncOperationCompletedHandler<Windows.Media.SpeechRecognition.SpeechRecognitionResult*>;
+                interface Windows.Foundation.IAsyncOperation<Windows.Media.SpeechRecognition.SpeechRecognitionResult*>;
+                interface Windows.Foundation.AsyncOperationCompletedHandler<Windows.Media.SpeechRecognition.SpeechRecognitionResult*>;
+
+                interface Windows.Foundation.Collections.IIterator<HSTRING* >;
+                interface Windows.Foundation.Collections.IIterable<HSTRING* >;
+                /* Following line is actually IVector not IVectorView! FIXME! */
+                interface Windows.Foundation.Collections.IVectorView<HSTRING*>;
+                /* Following line is actually IVector not IVectorView! FIXME! */
+                interface Windows.Foundation.Collections.IVectorView<Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint*>;
+                interface Windows.Foundation.TypedEventHandler<Windows.Media.SpeechRecognition.ISpeechRecognizer*, Windows.Media.SpeechRecognition.ISpeechRecognitionQualityDegradingEventArgs*>;
+                interface Windows.Foundation.TypedEventHandler<Windows.Media.SpeechRecognition.ISpeechRecognizer*, Windows.Media.SpeechRecognition.ISpeechRecognizerStateChangedEventArgs*>;
+
+                interface Windows.Foundation.TypedEventHandler<Windows.Media.SpeechRecognition.ISpeechRecognizer2*, Windows.Media.SpeechRecognition.ISpeechRecognitionHypothesisGeneratedEventArgs*>;
+            }
+        }
+    }
+}
+
+namespace Windows {
+    namespace Media {
+        namespace SpeechRecognition {
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            enum SpeechContinuousRecognitionMode
+            {
+                Default = 0,
+                PauseOnRecognition = 1
+            };
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            enum SpeechRecognitionAudioProblem
+            {
+                None = 0,
+                TooNoisy = 1,
+                NoSignal = 2,
+                TooLoud = 3,
+                TooQuiet = 4,
+                TooFast = 5,
+                TooSlow = 6,
+            };
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            enum SpeechRecognitionConfidence
+            {
+                High = 0,
+                Medium = 1,
+                Low = 2,
+                Rejected = 3,
+            };
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            enum SpeechRecognitionConstraintProbability
+            {
+                Default = 0,
+                Min = 1,
+                Max = 2,
+            };
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            enum SpeechRecognitionConstraintType
+            {
+                Topic = 0,
+                List = 1,
+                Grammar = 2,
+                VoiceCommandDefinition = 3,
+            };
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            enum SpeechRecognitionResultStatus
+            {
+                Success = 0,
+                TopicLanguageNotSupported = 1,
+                GrammarLanguageMismatch = 2,
+                GrammarCompilationFailure = 3,
+                AudioQualityFailure = 4,
+                UserCanceled = 5,
+                Unknown = 6,
+                TimeoutExceeded = 7,
+                PauseLimitExceeded = 8,
+                NetworkFailure = 9,
+                MicrophoneUnavailable = 10,
+            };
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            enum SpeechRecognitionScenario
+            {
+                WebSearch = 0,
+                Dictation = 1,
+                FormFilling = 2,
+            };
+
+            [contract(Windows.Foundation.UniversalApiContract, 1.0)]
+            enum SpeechRecognizerState
+            {
+                Idle = 0,
+                Capturing = 1,
+                Processing = 2,
+                SoundStarted = 3,
+                SoundEnded = 4,
+                SpeechDetected = 5,
+                Paused = 6,
+            };
+
+            [
+            contract(Windows.Foundation.UniversalApiContract, 1.0),
+            exclusiveto(Windows.Media.SpeechRecognition.SpeechContinuousRecognitionCompletedEventArgs),
+            uuid(e3d069bb-e30c-5e18-424b-7fbe81f8fbd0)
+            ]
+            interface ISpeechContinuousRecognitionCompletedEventArgs : IInspectable
+            {
+                [propget] HRESULT Status([out, retval] Windows.Media.SpeechRecognition.SpeechRecognitionResultStatus* value);
+            }
+
+            [
+            contract(Windows.Foundation.UniversalApiContract, 1.0),
+            exclusiveto(Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint),
+            uuid(09C487E9-E4AD-4526-81F2-4946FB481D98)
+            ]
+            interface ISpeechRecognitionListConstraint : IInspectable
+            {
+                [propget] HRESULT Commands([out, retval] Windows.Foundation.Collections.IVectorView<HSTRING*>** value);
+            }
+
+            [
+            contract(Windows.Foundation.UniversalApiContract, 1.0),
+            //exclusiveto(Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint),
+            uuid(40F3CDC7-562A-426A-9F3B-3B4E282BE1D5)
+            ]   
+            interface ISpeechRecognitionListConstraintFactory : IInspectable
+            {
+                HRESULT Create(
+                    [out, retval] Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint** listconstraint,
+                    [in] Windows.Foundation.Collections.IIterable<HSTRING*>* commands);
+
+                HRESULT CreateWithTag(
+                    [out, retval] Windows.Media.SpeechRecognition.SpeechRecognitionListConstraint** listconstraint,
+                    [in] Windows.Foundation.Collections.IIterable<HSTRING*>* commands,
+                    [in] HSTRING* tag);
+            }
+
+            [
+            contract(Windows.Foundation.UniversalApiContract, 1.0),
+            exclusiveto(Windows.Media.SpeechRecognition.SpeechRecognitionResult),
+            uuid(4E303157-034E-4652-857E-D0454CC4BEEC)
+            ]
+            interface ISpeechRecognitionResult : IInspectable
+            {
+                //[propget] HRESULT Status([out] [retval] Windows.Media.SpeechRecognition.SpeechRecognitionResultStatus* value);
+            }
+
+
+            [
+            contract(Windows.Foundation.UniversalApiContract, 1.0),
+            exclusiveto(Windows.Media.SpeechRecognition.SpeechRecognitionCompilationResult),
+            uuid(407E6C5D-6AC7-4DA4-9CC1-2FCE32CF7489)
+            ]
+            interface ISpeechRecognitionCompilationResult : IInspectable
+            {
+                //[propget] HRESULT Status([out] [retval] Windows.Media.SpeechRecognition.SpeechRecognitionResultStatus* value);
+            }
+
+            [
+            contract(Windows.Foundation.UniversalApiContract, 1.0),
+            exclusiveto(Windows.Media.SpeechRecognition.SpeechRecognitionCompilationResult),
+            uuid(738F00B1-E18C-5140-A53A-F1788D10C93D)
+            ]
+            interface ISpeechRecognitionConstraint : IInspectable
+            {
+                [propget] HRESULT IsEnabled([out, retval] boolean **value);
+                [propput] HRESULT IsEnabled([in] boolean *value);
+                [propget] HRESULT Probability([out, retval] Windows.Media.SpeechRecognition.SpeechRecognitionConstraintProbability **value);
+                [propput] HRESULT Probability([in] Windows.Media.SpeechRecognition.SpeechRecognitionConstraintProbability *value);
+                [propget] HRESULT Tag([out, retval] HSTRING **value);
+                [propput] HRESULT Tag([in] HSTRING *value);
+                [propget] HRESULT Type([out, retval] Windows.Media.SpeechRecognition.SpeechRecognitionConstraintType **value);
+                [propput] HRESULT Type([in] Windows.Media.SpeechRecognition.SpeechRecognitionConstraintType *value);
+            }
+
+            [
+            contract(Windows.Foundation.UniversalApiContract, 1.0),
+            exclusiveto(Windows.Media.SpeechRecognition.SpeechRecognitionCompilationResult),
+            uuid(4FE24105-8C3A-4C7E-8D0A-5BD4F5B14AD8)
+            ]
+            interface ISpeechRecognitionQualityDegradingEventArgs : IInspectable
+            {
+
+            }
+
+            [
+            contract(Windows.Foundation.UniversalApiContract, 1.0),
+            exclusiveto(Windows.Media.SpeechRecognition.SpeechRecognitionCompilationResult),
+            uuid(563D4F09-BA03-4BAD-AD81-DDC6C4DAB0C3)
+            ]
+            interface ISpeechRecognizerStateChangedEventArgs : IInspectable
+            {
+
+            }
+
+            [
+            contract(Windows.Foundation.UniversalApiContract, 1.0),
+            exclusiveto(Windows.Media.SpeechRecognition.SpeechRecognitionCompilationResult),
+            uuid(2EF76FCA-6A3C-4DCA-A153-DF1BC88A79AF)
+            ]
+            interface ISpeechRecognizerTimeouts : IInspectable
+            {
+
+            }
+
+            [
+            contract(Windows.Foundation.UniversalApiContract, 1.0),
+            exclusiveto(Windows.Media.SpeechRecognition.SpeechRecognitionCompilationResult),
+            uuid(7888D641-B92B-44BA-A25F-D1864630641F)
+            ]
+            interface ISpeechRecognizerUIOptions : IInspectable
+            {
+
+            }
+
+            [
+            contract(Windows.Foundation.UniversalApiContract, 1.0),
+            //exclusiveto(Windows.Media.SpeechRecognition.SpeechRecognitionCompilationResult),
+            uuid(6A213C04-6614-49F8-99A2-B5E9B3A085C8)
+            ]
+            interface ISpeechContinuousRecognitionSession : IInspectable
+            {
+
+            }
+
+            [
+            contract(Windows.Foundation.UniversalApiContract, 1.0),
+            //exclusiveto(Windows.Media.SpeechRecognition.SpeechRecognitionCompilationResult),
+            uuid(55161A7A-8023-5866-411D-1213BB271476)
+            ]
+            interface ISpeechRecognitionHypothesisGeneratedEventArgs : IInspectable
+            {
+
+            }
+
+            [
+            contract(Windows.Foundation.UniversalApiContract, 1.0),
+            exclusiveto(Windows.Media.SpeechRecognition.SpeechContinuousRecognitionCompletedEventArgs),
+            uuid(0BC3C9CB-C26A-40F2-AEB5-8096B2E48073)
+            ]
+            interface ISpeechRecognizer : IInspectable
+            {
+                HRESULT CompileConstraintsAsync(
+                        [out, retval] Windows.Foundation.IAsyncOperation<Windows.Media.SpeechRecognition.SpeechRecognitionCompilationResult*> **operation);
+                HRESULT RecognizeAsync([out, retval] Windows.Foundation.IAsyncOperation<Windows.Media.SpeechRecognition.SpeechRecognitionResult*> **operation);
+                HRESULT RecognizeWithUIAsync([out, retval] Windows.Foundation.IAsyncOperation<Windows.Media.SpeechRecognition.SpeechRecognitionResult*> **operation);
+                /* Following line is actually IVector not IVectorView! FIXME! */
+                [propget] HRESULT Constraints([out, retval] Windows.Foundation.Collections.IVectorView<Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint*> **vector);
+                [propget] HRESULT CurrentLanguage([out, retval] Windows.Globalization.Language **language);
+                [propget] HRESULT Timeouts([out, retval] Windows.Media.SpeechRecognition.ISpeechRecognizerTimeouts **timeouts);
+                [propget] HRESULT UIOptions([out, retval] Windows.Media.SpeechRecognition.ISpeechRecognizerUIOptions **options);
+                [eventadd] HRESULT RecognitionQualityDegrading(
+                        [in] Windows.Foundation.TypedEventHandler<Windows.Media.SpeechRecognition.ISpeechRecognizer*, Windows.Media.SpeechRecognition.ISpeechRecognitionQualityDegradingEventArgs*> *handler,
+                        [out, retval] EventRegistrationToken* token);
+                [eventremove] HRESULT RecognitionQualityDegrading(
+                        [in] EventRegistrationToken token);
+                [eventadd] HRESULT StateChanged(
+                        [in] Windows.Foundation.TypedEventHandler<Windows.Media.SpeechRecognition.ISpeechRecognizer*, Windows.Media.SpeechRecognition.ISpeechRecognizerStateChangedEventArgs*> *handler,
+                        [out, retval] EventRegistrationToken* token);
+                [eventremove] HRESULT StateChanged(
+                        [in] EventRegistrationToken token);
+            }
+
+            [
+            contract(Windows.Foundation.UniversalApiContract, 1.0),
+            exclusiveto(Windows.Media.SpeechRecognition.SpeechContinuousRecognitionCompletedEventArgs),
+            uuid(63C9BAF1-91E3-4EA4-86A1-7C3867D084A6)
+            ]
+            interface ISpeechRecognizer2 : IInspectable
+            {
+                HRESULT StopRecognitionAsync(
+                        [out, retval] Windows.Foundation.IAsyncAction **action);
+                /* This and some other methods actually return a class not an interaface. */
+                [propget] HRESULT ContinuousRecognitionSession([out, retval] Windows.Media.SpeechRecognition.ISpeechContinuousRecognitionSession **session);
+                [propget] HRESULT State([out, retval] Windows.Media.SpeechRecognition.SpeechRecognizerState *state);
+                [eventadd] HRESULT HypothesisGenerated(
+                        [in] Windows.Foundation.TypedEventHandler<Windows.Media.SpeechRecognition.ISpeechRecognizer2*, Windows.Media.SpeechRecognition.ISpeechRecognitionHypothesisGeneratedEventArgs*> *handler,
+                        [out, retval] EventRegistrationToken* token);
+                [eventremove] HRESULT HypothesisGenerated(
+                        [in] EventRegistrationToken token);
+            }
+
+            [
+            contract(Windows.Foundation.UniversalApiContract, 1.0),
+            //exclusiveto(Windows.Media.SpeechRecognition.SpeechContinuousRecognitionCompletedEventArgs),
+            uuid(60C488DD-7FB8-4033-AC70-D046F64818E1)
+            ]
+            interface ISpeechRecognizerFactory : IInspectable
+            {
+                HRESULT Create(
+                    [out, retval] Windows.Media.SpeechRecognition.ISpeechRecognizer** speechrecognizer,
+                    [in] Windows.Globalization.Language *language);
+            }
+
+            [
+                contract(Windows.Foundation.UniversalApiContract, 1.0),
+                marshaling_behavior(agile)
+            ]
+            runtimeclass SpeechContinuousRecognitionCompletedEventArgs
+            {
+                [default] interface Windows.Media.SpeechRecognition.ISpeechContinuousRecognitionCompletedEventArgs;
+            }
+
+            [
+                contract(Windows.Foundation.UniversalApiContract, 1.0),
+                marshaling_behavior(agile),
+                uuid(78C859BD-14D4-5C40-ABFF-490616D5E92D)
+            ]
+            runtimeclass SpeechRecognitionCompilationResult
+            {
+                [default] interface Windows.Media.SpeechRecognition.ISpeechRecognitionCompilationResult;
+            }
+
+            [
+                activatable(Windows.Foundation.UniversalApiContract, 1.0),
+                contract(Windows.Foundation.UniversalApiContract, 1.0),
+                marshaling_behavior(agile),
+                uuid(09C487E9-E4AD-4526-81F2-4946FB481D98)
+            ]
+            runtimeclass SpeechRecognitionListConstraint
+            {
+                [default] interface Windows.Media.SpeechRecognition.ISpeechRecognitionListConstraint;
+                interface Windows.Media.SpeechRecognition.ISpeechRecognitionConstraint;
+            }
+
+            [
+                contract(Windows.Foundation.UniversalApiContract, 1.0),
+                marshaling_behavior(agile),
+                uuid(BA3EEBE8-8D7C-51F2-9ED4-EBAFE3674DB4)
+            ]
+            runtimeclass SpeechRecognitionResult
+            {
+                [default] interface Windows.Media.SpeechRecognition.ISpeechRecognitionResult;
+                interface Windows.Media.SpeechRecognition.ISpeechRecognitionResult2;
+            }
+
+            [
+                activatable(Windows.Foundation.UniversalApiContract, 1.0),
+                contract(Windows.Foundation.UniversalApiContract, 1.0),
+                marshaling_behavior(agile),
+                uuid(0BC3C9CB-C26A-40F2-AEB5-8096B2E48073)
+            ]
+            runtimeclass SpeechRecognizer
+            {
+                [default] interface Windows.Media.SpeechRecognition.ISpeechRecognizer;
+                interface Windows.Media.SpeechRecognition.ISpeechRecognizer2;
+            }
+        }
+    }
+}
diff --git a/include/windows.media.speechsynthesis.idl b/include/windows.media.speechsynthesis.idl
index 29dca510dee..5b6092dbc98 100644
--- a/include/windows.media.speechsynthesis.idl
+++ b/include/windows.media.speechsynthesis.idl
@@ -139,7 +139,8 @@ namespace Windows {
 
             [
                 contract(Windows.Foundation.UniversalApiContract, 1.0),
-                marshaling_behavior(agile)
+                marshaling_behavior(agile),
+                uuid(00BD028A-E2AD-57AF-9829-F8B273D2717B)
             ]
             runtimeclass VoiceInformation
             {
-- 
2.34.1

