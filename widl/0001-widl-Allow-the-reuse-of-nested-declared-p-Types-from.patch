From be48bce577334769745bb08c7abcc1d0a4e8b637 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Bernhard=20K=C3=B6lbl?= <besentv@gmail.com>
Date: Thu, 27 Jan 2022 15:26:00 +0100
Subject: [PATCH] widl: Allow the reuse of nested declared p-Types from
 imported files.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Currently widl can't import declarations of nested parameterized types
from other idl files, so one has to delcare them all in the same file.
An example:

import "windows.foundation.idl";

namespace Windows {
  namespace Example {
    declare{
      interface Windows.Foundation.Collections.IVectorView<HSTRING>;
        ^~~~ In the WinRT SDK this is already declared in windows.foundation.idl, which makes this line redundant.

      interface Windows.Foundation.Collections.IIterator<Windows.Foundation.Collections.IVectorView<HSTRING> >;
      interface Windows.Foundation.Collections.IIterable<Windows.Foundation.Collections.IVectorView<HSTRING> >;
    }
  }
}

This commit fixes this by adding the declared p-types from imported files to
the parameterized statements list as STMT_TYPEREF, so they are ignored in the
header generation process.

Signed-off-by: Bernhard Kölbl <besentv@gmail.com>
---
Thanks to Rémi Bernon for helping me on this one. :)

 tools/widl/parser.y | 13 ++++++++-----
 1 file changed, 8 insertions(+), 5 deletions(-)

diff --git a/tools/widl/parser.y b/tools/widl/parser.y
index d6ac73cbf00..64ef82450c9 100644
--- a/tools/widl/parser.y
+++ b/tools/widl/parser.y
@@ -103,7 +103,7 @@ static statement_t *make_statement_importlib(const char *str);
 static statement_t *make_statement_module(type_t *type);
 static statement_t *make_statement_typedef(var_list_t *names, int declonly);
 static statement_t *make_statement_import(const char *str);
-static statement_t *make_statement_parameterized_type(type_t *type, typeref_list_t *params);
+static statement_t *make_statement_parameterized_type(type_t *type, typeref_list_t *params, enum statement_type stmt_type);
 static statement_t *make_statement_delegate(type_t *ret, var_list_t *args);
 static statement_list_t *append_statement(statement_list_t *list, statement_t *stmt);
 static statement_list_t *append_statements(statement_list_t *, statement_list_t *);
@@ -370,7 +370,7 @@ m_acf: /* empty */ | aACF acf_statements
 
 decl_statements:				{ $$ = NULL; }
 	| decl_statements tINTERFACE qualified_type '<' parameterized_type_args '>' ';'
-						{ parameterized_type_stmts = append_statement(parameterized_type_stmts, make_statement_parameterized_type($3, $5));
+						{ parameterized_type_stmts = append_statement(parameterized_type_stmts, make_statement_parameterized_type($3, $5, STMT_TYPE));
 						  $$ = append_statement($1, make_statement_reference(type_parameterized_type_specialize_declare($3, $5)));
 						}
 	;
@@ -379,7 +379,9 @@ decl_block: tDECLARE '{' decl_statements '}' { $$ = $3; }
 
 imp_decl_statements:				{ $$ = NULL; }
 	| imp_decl_statements tINTERFACE qualified_type '<' parameterized_type_args '>' ';'
-						{ $$ = append_statement($1, make_statement_reference(type_parameterized_type_specialize_declare($3, $5))); }
+						{ parameterized_type_stmts = append_statement(parameterized_type_stmts, make_statement_parameterized_type($3, $5, STMT_TYPEREF));
+						  $$ = append_statement($1, make_statement_reference(type_parameterized_type_specialize_declare($3, $5)));
+						}
 	;
 
 imp_decl_block: tDECLARE '{' imp_decl_statements '}' { $$ = $3; }
@@ -3138,6 +3140,7 @@ static statement_list_t *append_parameterized_type_stmts(statement_list_t *stmts
         switch(stmt->type)
         {
         case STMT_TYPE:
+        case STMT_TYPEREF:
             stmt->u.type = type_parameterized_type_specialize_define(stmt->u.type);
             stmt->declonly = FALSE;
             list_remove(&stmt->entry);
@@ -3327,9 +3330,9 @@ static statement_t *make_statement_typedef(declarator_list_t *decls, int declonl
     return stmt;
 }
 
-static statement_t *make_statement_parameterized_type(type_t *type, typeref_list_t *params)
+static statement_t *make_statement_parameterized_type(type_t *type, typeref_list_t *params, enum statement_type stmt_type)
 {
-    statement_t *stmt = make_statement(STMT_TYPE);
+    statement_t *stmt = make_statement(stmt_type);
     stmt->u.type = type_parameterized_type_specialize_partial(type, params);
     return stmt;
 }
-- 
2.34.1

